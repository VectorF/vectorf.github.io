<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vector Blog</title>
  <subtitle>Vector Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://VectorF.github.io/"/>
  <updated>2017-02-21T03:57:07.255Z</updated>
  <id>http://VectorF.github.io/</id>
  
  <author>
    <name>VectorF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>要优雅！一行代码搞定 R 语言模型输出！（使用 stargazer 包）</title>
    <link href="http://VectorF.github.io/2017/02/21/20170221-%E8%A6%81%E4%BC%98%E9%9B%85%EF%BC%81%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%20R%20%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA%EF%BC%81%EF%BC%88%E4%BD%BF%E7%94%A8%20stargazer%20%E5%8C%85%EF%BC%89/"/>
    <id>http://VectorF.github.io/2017/02/21/20170221-要优雅！一行代码搞定 R 语言模型输出！（使用 stargazer 包）/</id>
    <published>2017-02-21T08:30:30.000Z</published>
    <updated>2017-02-21T03:57:07.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文于 2017/02/08 发表在 <a href="http://datartisan.com/article/detail/202.html" target="_blank" rel="external">数据工匠</a> 网站中</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>使用<code>stargazer</code>包可以将 R 构建的模型结果以<code>LATEX</code>、<code>HTML</code>和<code>ASCII</code>格式输出，方便我们生成标准格式的表格。</p>
<p>再结合<code>rmarkdown</code>，你就可以轻轻松松输出一篇优雅的文章啦~</p>
<p>本文“使用说明”部分主要参考<code>stargazer</code>的<a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" title="stargezer.pdf" target="_blank" rel="external">说明文档</a>。</p>
<h2 id="安装及加载"><a href="#安装及加载" class="headerlink" title="安装及加载"></a>安装及加载</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"stargazer"</span>)</div><div class="line"><span class="keyword">library</span>(stargazer)</div></pre></td></tr></table></figure>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>**注意：<code>stargazer</code>包的输出结果是相应格式的，例如输出<code>LATEX</code>格式，可以直接将结果粘贴进<code>WinEdt</code>等编辑器中输出表格。下文直接将结果以表格的形式展示。</p>
<p>我们使用 R 中自带的数据集<code>attitude</code>来简要说明<code>stargazer</code>包的用法。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data(<span class="string">"attitude"</span>)</div></pre></td></tr></table></figure>
<p><code>attitude</code>数据集中包括<code>rating</code>、<code>complaints</code>等八个变量：</p>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/0.png" alt="0"><br><br></div>

<p>1.展示数据集的描述性分析和部分数据集内容</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示数据集的描述性分析</span></div><div class="line">stargazer(attitude,header = <span class="literal">F</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/1.png" alt="1"><br><br></div>

<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示attitude数据集的前四行</span></div><div class="line">stargazer(attitude[<span class="number">1</span>:<span class="number">4</span>,], summary=<span class="literal">FALSE</span>, rownames=<span class="literal">FALSE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/2.png" alt="2"><br><br></div>

<p>怎么样？！是不是感觉还不错~</p>
<p>2.展示线性模型结果，并加上表名</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建线性和Probit模型</span></div><div class="line">linear.1 &lt;- lm(rating ~ complaints + privileges + learning + raises + critical,data=attitude)</div><div class="line">linear.2 &lt;- lm(rating ~ complaints + privileges + learning, data=attitude)</div><div class="line">attitude$high.rating &lt;- (attitude$rating &gt; <span class="number">70</span>)</div><div class="line">probit.model &lt;- glm(high.rating ~ learning + critical + advance, data=attitude,family = binomial(link = <span class="string">"probit"</span>))</div><div class="line"><span class="comment"># 展示模型结果</span></div><div class="line">stargazer(linear.1, linear.2, probit.model, title=<span class="string">"Results"</span>,align=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/3.png" alt="3"><br><br></div>

<p>我们构建了两个线性模型和一个 Probit 模型，并将结果输出。</p>
<p>使用<code>title</code>参数将其命名为“Results”；</p>
<p>使用<code>align</code>参数使数字排列整齐。</p>
<p>3.对模型结果输出做部分调整：</p>
<ul>
<li>更改变量名；</li>
<li>删除极大似然统计量、残差标准差、F统计量；</li>
<li>删除表中的空行。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stargazer(linear.1, linear.2, probit.model, </div><div class="line">          title=<span class="string">"Regression Results"</span>, align=<span class="literal">TRUE</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          covariate.labels=c(<span class="string">"Handling of Complaints"</span>,<span class="string">"No Special Privileges"</span>,<span class="string">"Opportunity to Learn"</span>,<span class="string">"Performance-Based Raises"</span>,<span class="string">"Too Critical"</span>,<span class="string">"Advancement"</span>),</div><div class="line">          omit.stat=c(<span class="string">"LL"</span>,<span class="string">"ser"</span>,<span class="string">"f"</span>), no.space=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/4.png" alt="4"><br><br></div>

<p>使用<code>dep.var.labels</code>和<code>covariate.lables</code>参数分别将因变量和自变量重命名为容易理解的形式；</p>
<p>使用<code>omit.stat</code>参数控制对数似然比（“LL”）、标准化残差（“ser”）和F统计量（“f”），这三个统计量不在输出结果中展示；</p>
<p>使用<code>no.space</code>参数将输出表格中的空行删去。</p>
<p>4.展示置信区间</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">targazer(linear.1, linear.2, </div><div class="line">          title=<span class="string">"Regression Results"</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          covariate.labels=c(<span class="string">"Handling of Complaints"</span>,<span class="string">"No Special Privileges"</span>,<span class="string">"Opportunity to Learn"</span>,<span class="string">"Performance-Based Raises"</span>,<span class="string">"Too Critical"</span>,<span class="string">"Advancement"</span>),</div><div class="line">          omit.stat=c(<span class="string">"LL"</span>,<span class="string">"ser"</span>,<span class="string">"f"</span>),</div><div class="line">         ci=<span class="literal">TRUE</span>, ci.level=<span class="number">0.90</span>, single.row=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/5.png" alt="5"><br><br></div>

<p>使用<code>ci</code>和<code>ci.level</code>参数展示90%的置信区间；</p>
<p>使用<code>single.row</code>参数使估计量与置信区间并排展示。</p>
<p>5.调整变量展示顺序，加上样本量，并移除其他统计量</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stargazer(linear.1, linear.2, title=<span class="string">"Regression Results"</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          order=c(<span class="string">"learning"</span>, <span class="string">"privileges"</span>),</div><div class="line">          keep.stat=<span class="string">"n"</span>, ci=<span class="literal">TRUE</span>, ci.level=<span class="number">0.90</span>, single.row=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/6.png" alt="6"><br><br></div>

<p>使用<code>order</code>参数控制自变量展示的顺序，即将<code>learning</code>和<code>privileges</code>放在表的前两行；</p>
<p>使用<code>keep.stat</code>参数控制要展示的统计量，<code>keep.stat=&quot;n&quot;</code>即只展示样本量的大小，并移除其他统计量。</p>
<p>6.以<code>ASCII</code>格式输出：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stargazer(linear.1, linear.2, type=<span class="string">"text"</span>, title=<span class="string">"Regression Results"</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          covariate.labels=c(<span class="string">"Handling of Complaints"</span>,<span class="string">"No Special Privileges"</span>,<span class="string">"Opportunity to Learn"</span>,<span class="string">"Performance-Based Raises"</span>,<span class="string">"Too Critical"</span>,<span class="string">"Advancement"</span>),</div><div class="line">          omit.stat=c(<span class="string">"LL"</span>,<span class="string">"ser"</span>,<span class="string">"f"</span>), ci=<span class="literal">TRUE</span>, ci.level=<span class="number">0.90</span>, single.row=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/7.png" alt="7"><br><br></div>

<p>使用<code>type</code>参数控制以<code>ASCII</code>格式输出，还可以选择输出<code>HTML</code>格式。默认为<code>LATEX</code>格式。</p>
<p>相应地，将<code>type</code>参数分别设置为<code>text</code>、<code>html</code>、<code>latex</code>即可。</p>
<p>7.展示矩阵</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">correlation.matrix &lt;-cor(attitude[,c(<span class="string">"rating"</span>,<span class="string">"complaints"</span>,<span class="string">"privileges"</span>)])</div><div class="line">stargazer(correlation.matrix, title=<span class="string">"Correlation Matrix"</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/8.png" alt="8"><br><br></div>

<p><code>stargazer</code>也可以用来展示向量、矩阵或者数据框的内容。</p>
<p>我们建立了<code>attitude</code>数据集中变量<code>rating</code>、<code>complaints</code>、<code>privileges</code>的相关系数矩阵，并展示出来。</p>
<p>8.自定义变量</p>
<p>我们使用<code>sandwich</code>包来计算异方差-稳健标准误，并将其与默认计算的标准差一同展示。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装及加载"sandwich"包</span></div><div class="line">install.packages(<span class="string">"sandwich"</span>)</div><div class="line"><span class="keyword">library</span>(sandwich)</div><div class="line"><span class="comment"># 计算异方差-稳健标准误</span></div><div class="line">cov&lt;-vcovHC(linear.1,type=<span class="string">"HC"</span>)</div><div class="line">robust.se&lt;-sqrt(diag(cov))</div><div class="line">stargazer(linear.1,linear.1,se=list(<span class="literal">NULL</span>,robust.se),column.labels = c(<span class="string">"default"</span>,<span class="string">"robust"</span>))</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/9.png" alt="9"><br><br></div>

<h2 id="与-rmarkdown-一起食用"><a href="#与-rmarkdown-一起食用" class="headerlink" title="与 rmarkdown 一起食用"></a>与 <code>rmarkdown</code> 一起食用</h2><p><code>rmarkdown</code>包可直接在<code>RStudio</code>中编辑符合 <code>markdown</code>语法的文档，并兼容<code>LATEX</code>格式。而且可以直接输出成<code>HTML</code>、<code>pdf</code>等格式的文档。</p>
<p>因此，<code>stargazer</code>与<code>rmarkdown</code>一起食用，风味更佳~</p>
<p>首先，你需要在<code>Rstudio</code>中安装<code>rmarkdown</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"rmarkdown"</span>)</div></pre></td></tr></table></figure>
<p>然后，就可以原先新建脚本的地方发现，可以新建一个<code>R Markdown</code>文件啦。</p>
<p>在<code>rmarkdown</code>中，用如下所示的形式来表示代码块：</p>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/10.png" alt="10"><br><br></div>

<p>注意以下几点：</p>
<ul>
<li>要加上<code>results=&#39;asis&#39;</code>保证输出的是表格，而不是<code>LATEX</code>格式；</li>
<li>参数<code>align</code>失效，不能加上；</li>
<li>加上参数<code>header=F</code>，以避免输出关于包作者的一些信息。</li>
</ul>
<p>其余用法与上述使用说明基本相同。这样就可以直接输出如上所示的表格了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>stargazer</code>用一行代码就可以解决模型结果输出成表格的问题，而且支持大量模型。具体可查看该包的<a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" title="stargezer.pdf" target="_blank" rel="external">说明文档</a>。</p>
<p>最后，如果在你的文章中有使用了<code>stargazer</code>包。记得附注以下作者的信息哦。</p>
<blockquote>
<p>Hlavac, Marek (2015). stargazer: Well-Formatted Regression and Summary Statistics Tables.<br>R package version 5.2. <a href="http://CRAN.R-project.org/package=stargazer" target="_blank" rel="external">http://CRAN.R-project.org/package=stargazer</a></p>
</blockquote>
<hr>
<p>点击链接到 <a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" title="stargezer.pdf" target="_blank" rel="external"><code>stargazer</code>包的说明文档地址</a></p>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文于 2017/02/08 发表在 &lt;a href=&quot;http://datartisan.com/article/detail/202.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据工匠&lt;/a&gt; 网站中&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="教程" scheme="http://VectorF.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="R" scheme="http://VectorF.github.io/categories/%E6%95%99%E7%A8%8B/R/"/>
    
    
      <category term="教程" scheme="http://VectorF.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="R 语言" scheme="http://VectorF.github.io/tags/R-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>揭开机器学习的面纱</title>
    <link href="http://VectorF.github.io/2017/02/20/20170221-%E6%8F%AD%E5%BC%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%9D%A2%E7%BA%B1/"/>
    <id>http://VectorF.github.io/2017/02/20/20170221-揭开机器学习的面纱/</id>
    <published>2017-02-20T08:30:30.000Z</published>
    <updated>2017-02-21T03:59:57.154Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://quantdare.com/2016/03/machine-learning-a-brief-breakdown/" target="_blank" rel="external">Machine Learning: A Brief Breakdown</a>   原文作者：libesa</p>
<p>译文于 2017/01/19 发表在 <a href="http://datartisan.com/article/detail/197.html" target="_blank" rel="external">数据工匠</a> 网站中</p>
</blockquote>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/0.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>你周围的人是否都在谈论着“机器学习”？而你是否也听说过一些算法技术却仍旧缺乏一个全局的认识？本文也许就是一个好的起点……</p>
</blockquote>
<h3 id="智力的新纪元"><a href="#智力的新纪元" class="headerlink" title="智力的新纪元"></a>智力的新纪元</h3><p>在科学界，机器学习是目前很热门的话题。通过把计算机和人类的能力相结合，一些相当复杂甚至是难以想象的问题正在被逐个突破。</p>
<p>如今的机器可以更容易地处理不断产生的大量数据，也能够对复杂的科学发现进行破译。另一方面，研究人员已经承认机器学习具有用于广泛领域的潜力，并且最终可以付诸实践。</p>
<p>当开始着手研究机器学习，我们会发现这其中很多的算法技术对于统计学家、工程师、程序员、数学家和金融工程师而言也许并不陌生。这是因为这些算法技术实际上已经被研究很多年了。“机器学习”是一个相对而言的新名词，但对于数据科学家而言这并不是一个完全陌生的领域。</p>
<p>本文汇总了原作者在研究初时遇到的一些有趣的实例，从而有助于理解机器学习的相关内容是如何联系在一起，并列出其知识体系各部分之间的不同之处，最终针对现有的项目，选择最佳的方案。</p>
<p>虽然本文并没有提出什么新的观点，甚至算不上专业，但原作者希望本文可以帮助那些对入门机器学习仍有疑惑的人。</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/1.jpg" alt="1"><br><br></div>

<h3 id="“机器学习”是什么？"><a href="#“机器学习”是什么？" class="headerlink" title="“机器学习”是什么？"></a>“机器学习”是什么？</h3><p>在机器学习领域，我们让机器自主学习。他们通过给定数据集里的案例进行学习。人们只需要利用机器得到的结论去改善方案、提高效率、实现自动化流程和任务。</p>
<p>让我们引用该领域两位巨擘的话来更精确地解释：</p>
<blockquote>
<p>“机器学习是让计算机在不被明确编程的情况下运作的科学。” ——安德鲁·吴（Coursera）</p>
<p>“一种计算机程序，如果它的任务记为T，用P来测度性能，并通过经验E来改善的话，它就会不断地从经验E中学习，从而满足某类任务T和性能指标P。”——汤姆·米歇尔（1997） </p>
</blockquote>
<h3 id="我曾经听说过这个！"><a href="#我曾经听说过这个！" class="headerlink" title="我曾经听说过这个！"></a>我曾经听说过这个！</h3><p>听起来，“机器学习”（简称为ML）和你之前了解的其他科学十分相似。现在，让我们看看它们之间究竟有什么不同。</p>
<p>或许，你对“人工智能”（简称为AI）更加熟悉。人工智能是通过复制人类的基本意识来开发系统项目从而独立完成预设好的目标的科学。很大程度上，机器学习可以算作是通过创造算法来调整机器行为从而接近经验数据的人工智能。</p>
<p>很多机器学习的内容来源于统计学科，只不过叫法不同罢了。与传统的统计学科不同，在机器学习中机器不对数据做推断，它得到的结论也不会被最初的诸多假设所限定。回想一下你在统计学中听到了多少次“假设X服从正态分布”或者“给定独立同分布的随机变量”。你有想过这些假设在现实中真的可能成立吗？</p>
<p>然而，机器学习方法的一个缺点在于我们很难得到对变量之间关系的直观解释，而这恰恰是统计推理所擅长的。为了实现更精确的预测，机器学习得到的模型会变得相当复杂以至于难以去解释。</p>
<p>失去解释性是绝大多数数据科学家不愿意见到的，但这也是为了解决复杂问题必须付出的代价。通常来说，在机器学习中最重要的是解决整个问题而不需要去分析细节。你能够不依赖其他技术发现数据背后隐藏的信息吗？尝试在下面这个色彩丰富的图中找出隐藏的三个物体，你能看到什么？</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/2.jpg" alt="2"><br><br></div>

<p>“机器学习”和“数据挖掘”也很相似。然而数据挖掘主要是为了发现数据中未知的模式和关系，机器学习则是在实际应用中通过先前得来的信息来处理新的数据集。</p>
<p>问题的关键在于平衡好性能和解释性的关系，比如说，预测准确性 vs 解释性。</p>
<p>如果你仍旧对机器学习与其他学科的异同留有困惑，你可以在<a href="https://www.analyticsvidhya.com/blog/2015/06/machine-learning-basics/" target="_blank" rel="external">“这里”</a>和<a href="http://shakthydoss.com/what-is-the-difference-between-artificial-intelligence-machine-learning-statistics-and-data-mining/" target="_blank" rel="external">“这里”</a>找到机器学习和人工智能、统计、数据挖掘、深度学习的比较。</p>
<h3 id="揭开机器学习的面纱"><a href="#揭开机器学习的面纱" class="headerlink" title="揭开机器学习的面纱"></a>揭开机器学习的面纱</h3><p>理解机器学习和学习如何入门最好的方法莫过于理解其知识体系各部分之间的不同之处。熟悉机器学习的人可能知道机器学习的主要模式就是监督学习和无监督学习了。</p>
<p>简而言之，监督学习就是我们已经通过之前已知的数据知道结果了。</p>
<p>此时，我们想建立一个模型来预测未知数据的结果。我们将已有的数据和结果输入机器，让它从这两者之间的关系中不断学习从而建立模型。</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/3.png" alt="3"><br><br></div>

<p>在无监督学习中，我们则是希望发现数据中未知的结构或者是趋势。原数据不含任何的标签，但我们希望可以对数据进行整合（分组或者聚类），或是简化数据（降维、移除不必要的变量或者检测异常值）。</p>
<p>我们进一步区分这两个模式的子类别，并在下图中展示出来：</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/4.png" alt="4"><br><br></div>

<p>监督学习可以根据预测变量的类型再细分。如果预测变量是连续的，那这就属于回归问题。</p>
<p>而如果预测变量是独立类别（定性或是定类的离散值），那这就属于分类问题了。</p>
<p>举例来说，如下两图所示：</p>
<ol>
<li>预测 S&amp;P500 指数下周的回报率。由于回报率是连续变量，这就是回归问题。</li>
<li>预测欧元兑美元的趋势是上升还是下降。这里只有两种可能性：牛市或熊市。这就是分类问题。</li>
</ol>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/5_0.png" alt="5_0"><br><br></div>

<p>无监督学习可以再细分为聚类分析、密度估计和降维。</p>
<p>聚类分析中，数据通过相似性或者距离来分组。密度估计中，模式和数据用分布函数或是定义的形状表示。降维中，通过移除重复或者不必要的变量实现更简洁的数据结构。</p>
<p>我们也可以根据学习的类型和所需解决的问题对特定的方法进行分类，如下图所示：</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/6.png" alt="6"><br><br></div>

<p><a href="http://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/" target="_blank" rel="external">“MLmastery”</a>和<a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" target="_blank" rel="external">“analyticsV”</a>等博文对机器学习主要的算法做了清晰实用的解释。</p>
<h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>机器学习技术在应用之前使用“训练+检验”的模式（通常被称作”交叉验证“）。</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/7.png" alt="7"><br><br></div>

<p>机器会不断地尝试参数的组合，因此我们要警惕“过拟合”和“运行时间”的问题。在训练阶段过高的准确性往往会造成过度优化，以至于在检验阶段会有较差的结果。同时，为了减小成本函数到足够的水平，算法也会花很长时间直至收敛到最终的结果。</p>
<h3 id="关于实际应用"><a href="#关于实际应用" class="headerlink" title="关于实际应用"></a>关于实际应用</h3><p>机器学习可谓是无处不在，在日常生活中有大量相关实例，只是我们没有意识到。比如说，机器学习被用于搜索引擎、过滤垃圾邮件、面部识别、社交网络分析、市场细分、数据分析、欺诈检测和风险分析等。</p>
<p>泛泛而谈是不足以说明问题的。通过将机器学习用于金融领域的实例，我们能看到将这些复杂的算法用于实际会带来多大的便利。</p>
<p>无监督学习技术可以用于分析和理解金融数据。比如说，<a href="http://quantdare.com/2014/03/analisis-de-componentes-principales/" target="_blank" rel="external">主成分分析（PCA）</a>可以用于资产配置，<a href="http://quantdare.com/2015/10/k-means-algorithm/" target="_blank" rel="external">K 均值</a>可用来债券市场回报率的聚类，<a href="http://quantdare.com/2015/05/reproducing-the-sp500-by-clustering/" target="_blank" rel="external">其他聚类方法</a>可以再现 S&amp;P 500指数的组成，<a href="http://quantdare.com/2016/01/stock-classification-with-isomap/" target="_blank" rel="external">ISOMAPS</a> 算法可以分类不同行业的股票。</p>
<p>监督学习技术则非常适合用于分析金融数据。它可以实现预测和帮助制定投资风险策略。举例来说，<a href="http://quantdare.com/2014/03/vecinos-serie-temporal/" target="_blank" rel="external">近邻算法</a>、<a href="http://quantdare.com/2014/07/redes-neuronales-ii/" target="_blank" rel="external">神经网络</a>、<a href="http://quantdare.com/2014/09/clasificando-mercado-con-arboles-de-decision/" target="_blank" rel="external">决策树</a>、<a href="http://quantdare.com/2015/01/random-forest-vs-simple-tree/" target="_blank" rel="external">随机森林</a>和<a href="http://quantdare.com/2015/10/naive_bayesian_classifier/" target="_blank" rel="external">贝叶斯</a>这些都可以用来监测股市的市场变动趋势。</p>
<h3 id="更多相关链接"><a href="#更多相关链接" class="headerlink" title="更多相关链接"></a>更多相关链接</h3><p>不知道从何开始？可以尝试<a href="https://www.coursera.org/learn/machine-learning/" target="_blank" rel="external">“在Coursera上的机器学习课程”</a>或者用Python的<a href="http://scikit-learn.org/stable/user_guide.html" target="_blank" rel="external">”tool scikit-learn“</a>。当然，你也可以在<a href="https://www.kaggle.com/competitions" target="_blank" rel="external">”Kaggle“</a>上进行学习，”泰坦尼克号’’实例很适合初学者。</p>
<p>想知道究竟什么算法才适合解决你的问题？不如去看看<a href="http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" rel="external">“scikit learn”</a>和<a href="https://azure.microsoft.com/en-us/documentation/articles/machine-learning-algorithm-choice/" target="_blank" rel="external">“Azure”</a>。</p>
<p>如果你想开始编程并尝试一些实例，<a href="http://topepo.github.io/caret/index.html" target="_blank" rel="external">“caret Package”</a>中包含大量的相关细节、函数和案例。你也可以从<a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">”Python and R codes“</a>中学到机器学习主要的算法。</p>
<p>不喜欢本文？想了解更多或想换个角度看？<a href="http://www.toptal.com/machine-learning/machine-learning-theory-an-introductory-primer" target="_blank" rel="external">“detailed post”</a>介绍了机器学习的入门知识，或是阅读<a href="http://www.r2d3.us/visual-intro-to-machine-learning-part-1/" target="_blank" rel="external">“innovative introductory visualisation”</a>。</p>
<p>在机器学习中有很多不同的词实际上代表同一样东西。下图是对于输入和输出变量的常见的一些表达方式：</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/8.png" alt="8"><br><br></div>

<p>你也可以在<a href="http://robotics.stanford.edu/~ronnyk/glossary.html" target="_blank" rel="external">“Glossary”</a>找到更多与机器学习相关的术语。</p>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://quantdare.com/2016/03/machine-learning-a-brief-breakdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Machine Learn
    
    </summary>
    
      <category term="翻译" scheme="http://VectorF.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="机器学习" scheme="http://VectorF.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="http://VectorF.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="监督学习" scheme="http://VectorF.github.io/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="无监督学习" scheme="http://VectorF.github.io/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ECharts 测试</title>
    <link href="http://VectorF.github.io/2016/12/29/20161229-ECharts%E6%B5%8B%E8%AF%95/"/>
    <id>http://VectorF.github.io/2016/12/29/20161229-ECharts测试/</id>
    <published>2016-12-29T12:30:30.000Z</published>
    <updated>2016-12-29T13:45:48.483Z</updated>
    
    <content type="html"><![CDATA[<script src="http://oiy82v3pb.bkt.clouddn.com/echarts.js"></script>
<div id="main" style="width: 600px;height:400px;" align="center"></div>
<script type="text/javascript">
var myChart = echarts.init(document.getElementById('main'));

var option = {
title: {
text: 'ECharts 入门示例'
},
tooltip: {},
legend: {
data:['销量']
},
xAxis: {
data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
},
yAxis: {},
series: [{
name: '销量',
type: 'bar',
data: [5, 20, 36, 10, 10, 20]
}]
};

myChart.setOption(option);
</script>
]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;http://oiy82v3pb.bkt.clouddn.com/echarts.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot; align=&quot;center&quot;&gt;&lt;/div&gt;

    
    </summary>
    
      <category term="ECharts" scheme="http://VectorF.github.io/categories/ECharts/"/>
    
    
      <category term="ECharts" scheme="http://VectorF.github.io/tags/ECharts/"/>
    
      <category term="测试" scheme="http://VectorF.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习与 Dota2 英雄属性</title>
    <link href="http://VectorF.github.io/2016/12/11/20161210-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8EDota2%E8%8B%B1%E9%9B%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://VectorF.github.io/2016/12/11/20161210-机器学习与Dota2英雄属性/</id>
    <published>2016-12-11T08:30:30.000Z</published>
    <updated>2017-02-21T03:57:45.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://federicov.github.io/word-embeddings-and-dota2.html" target="_blank" rel="external">《 Gavagai 》</a>   原文作者：Federico Vaggi</p>
<p>译文于 2016/12/10 发表在 <a href="http://datartisan.com/article/detail/181.html" target="_blank" rel="external">数据工匠</a> 网站中</p>
</blockquote>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/fenmian.jpg" width="800" height="350" alt="dota2"><br><br></div>

<p>本文使用自然语言处理（ NLP ）方法对 DOTA2 英雄角色属性做了简要的分析。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a><strong>1. 引言</strong></h2><p>如果有人问你“兔子”是什么意思，你会怎么回答？你可能会跑出去，每次看到一只兔子就指给那个人看，说“喏，那就是兔子。”当然那个人得和你三观相近，你才能解释得通。那如果对方对世界的认知方式和你不同，你要怎么向他解释？<br>这就是为什么要引入”词向量（ word vector ）”这个概念。”词向量”基于分布假定，即“语义相近的词语往往会出现在相似的内容中”。<br>在语言学中，如果你发现“ negotiate ”和“ bargain ”总是出现在相似的内容里，它们的语义就可能也是相近的。通过将词语向量化，再去计算向量化后“ negotiate ”和“ bargain ”的余弦相似度（一种测量两个向量间相似性的方法），你会发现相似度的值会接近 1 。词向量也常用于利用相似性去解释一些东西，比如说“皇帝”是“男人”，“皇后”就是“女人”。</p>
<h2 id="2-从词向量到英雄向量"><a href="#2-从词向量到英雄向量" class="headerlink" title="2. 从词向量到英雄向量"></a><strong>2. 从词向量到英雄向量</strong></h2><p>那么词向量怎么帮助我们去认识 Dota2 中的队伍呢？你可以想象每只 Dota2 的队伍配置都是由不同英雄做单词从而组成的句子，比如说：蝙蝠骑士、干扰者、拉席克、娜迦海妖、编织者，又或者：龙骑士、编织者、水晶室女、风行者、树精卫士。<br>正如上文提到的分布假定所说的那样，只是这次我们不通过每个词所在的句子去判断词语的意思，而是通过每个 Dota2 英雄所在的队伍去判断每个英雄的角色属性。具体来说，如果我们发现“巫医”和“莱恩”总是出现在相似的队伍里，那么他们可能就具有相似的角色属性。<br>本文使用 <a href="http://www.datdota.com/" target="_blank" rel="external">datdota</a> 作为数据来源，并使用 <a href="https://radimrehurek.com/gensim/index.html" target="_blank" rel="external">gensim library</a> 使我们的英雄向量化。<br>举例来说，通过对数据集的训练，“影魔”这个英雄向量化后大致如下：<br>[-0.06813218, -0.00902375, 0.10162564, -0.01908037, 0.03013835,<br>0.16538762, 0.03104097, 0.02496031, -0.16785616, 0.3313826 ,<br>-0.21904311, -0.07945664, 0.19140202, 0.12729862, 0.36308175,<br>0.19962946, 0.13561839, 0.23637122, -0.32607114, 0.05647549,<br>0.09655968, -0.21899879, 0.04926173, 0.12474103, 0.14504923,<br>0.06281823, 0.14728694, -0.03583163, -0.00227163, 0.1205247 ,<br>0.01127683, 0.01522848, 0.13806115, 0.0216765 , 0.13671157,<br>-0.1683237 , 0.00408782, 0.10514087, -0.17610508, 0.04697264,<br>-0.03406512, -0.14956233, 0.20201634, 0.00907436, -0.05804597,<br>-0.00481437, 0.11493918, -0.07718568, -0.13443205, -0.01155808]<br>这样，“影魔”这个英雄现在变成了 50 维空间里的一个点，但是把一个词变成 50 个数字并没有什么用处。现在来做一些炫酷的事吧！还是拿“影魔”为例，我们找出和它相似的一些英雄向量：</p>
<ol>
<li>痛苦女王：0.9340388774871826</li>
<li>风暴之灵：0.9170020818710327</li>
<li>冥界亚龙：0.9082884788513184</li>
<li>狙击手：0.8958033919334412</li>
<li>宙斯：0.8526902794837952</li>
</ol>
<p>（数字代表这些向量化后的英雄和“影魔”的余弦相似性）<br>下图则更直观地将结果进行展示，图中每行代表一个向量化后的英雄。</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/1.png" alt="1"><br><br></div>

<p>这就看起来有点感觉了，接下来再尝试一些更难的东西看看我们是不是能通过这些向量化后的英雄来解释它们之间的相似性，就像“莱恩”和“敌法师”相似，而“巫医”则和以下英雄相似：</p>
<ol>
<li>幽鬼：0.9638912677764893</li>
<li>幻影长矛手：0.9185065031051636</li>
<li>幻影刺客：0.9039324522018433</li>
<li>变体精灵：0.858444333076477</li>
<li>噬魂鬼：0.8570600748062134</li>
</ol>
<p>虽然这些分析可能不能帮助你打赢 PPD ,但至少下次你就知道该挑选哪些英雄来组队。</p>
<h2 id="3-全局视角"><a href="#3-全局视角" class="headerlink" title="3. 全局视角"></a><strong>3. 全局视角</strong></h2><p>我们可以把所有英雄同时展示在一张图里，但这难免让人眼花缭乱。</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/2.png" alt="2"><br><br></div>

<p>如上图所示，每一列对应一个英雄，并把行列以树状图的形式展示出来。不过除非你已经看惯了这些图，不然直观地分清哪些英雄是一类的或者判断出哪个英雄和别的相似还是挺难的。<br>我们将树状图精简展示出来，来看看那些英雄是相似的，结果如下图所示：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/3.png" alt="3"><br><br></div>

<p>截至目前，我们已经得到了一些有意义（虽然并不完美）的英雄分类群体了，比如“劣势路单”群体包括了末日使者、司夜刺客、黑暗贤者、钢背兽和半人马战行者，“强核心”群体包括了卓尔游侠、斯拉克、幻影长矛手和噬魂鬼，而“力量支持”群体则包括了冥魂大帝、巨牙海民和亚巴顿。<br>当然有其他方式来展示分类的结果。我们可以使用 <a href="https://lvdmaaten.github.io/tsne/" target="_blank" rel="external">t-SNE</a> 将 50 维的数据以二维的形式展示出来。 <a href="https://lvdmaaten.github.io/tsne/" target="_blank" rel="external">t-SNE</a> 是一种在尽可能不破坏原有高维数据结构的基础上以低维形式展示数据的方法。<br>在对数据进行处理并在二维空间绘图后，我们可以得到下图：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/4.png" alt="4"><br><br></div>

<p>图中英雄不同的颜色来自于上文的分类结果，直观地看这些离散分类还是具有一定意义的。</p>
<h2 id="4-向量到底代表什么？"><a href="#4-向量到底代表什么？" class="headerlink" title="4. 向量到底代表什么？"></a><strong>4. 向量到底代表什么？</strong></h2><p>那么我们给每个英雄赋的值到底代表什么呢？“影魔”在第一维空间里的值为 -0.06813218 ，这个值代表什么意思？通常情况下，我们会说这些是潜在的属性值，就不再深究了。但在这个实例里，我们可以再深入一点。<br><a href="http://dota2.gamepedia.com/Dota_2_Wiki" target="_blank" rel="external">Dota2 gamepedia</a> 给每个英雄都赋予了一系列角色属性。虽然这个属性有待商榷，而且在打完补丁之后有的英雄可能会从辅助变成核心，但是这仍然可以作为一个不错的出发点。<br>现在，我们已经为接下来的分析做好准备了。回想一下之前我们已经用 50 个数字来刻画每个英雄了，并且从 <a href="http://dota2.gamepedia.com/Dota_2_Wiki" target="_blank" rel="external">Dota2 gamepedia</a> 网站中也有了每个英雄对应的角色属性。<br>我们想验证向量维度和英雄的角色属性之间是否有一定的联系。有很多方法可以实现，但可能最简单的方式就是使用 Logistic 回归了。<br>为了能得到稀疏集，我们使用 L1 范数规则化。<br>结果如下图所示：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/5.png" alt="5"><br><br></div>

<p>这幅图又意味着什么呢？我们可以看到第 46 个向量和“辅助”有很强的相关性，第 38 个向量和“远程英雄”联系紧密。下图是所有英雄第 38 和第 46 个向量值的散点图：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/6.png" alt="6"><br><br></div>

<p>可以看出第 46 个向量值大的英雄很可能是辅助英雄。相似地，第 38 个向量值大的英雄很可能是打远程的。当然，你可能注意到这两个向量似乎有点相关（虽然相关性并不是那么强），不过这也正好与辅助英雄往往也是打远程的情况相符。上图也将不朽尸王、上古巨神、亚巴顿这些近战支援（辅助属性高，远程属性低）的英雄正确识别出来了，但卓尔游侠的向量值却和角色属性不符，而且克林克兹也是一个近战支援的英雄（图中其第 38 和 46 个向量值都不高，与事实不太相符）。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h2><p>一旦涉及到计算机领域，每次英雄的选派都可以看作是没有实际意义的随机序列，但是从这里出发，却能得到可以被较好解释的信息。因此，在训练这些向量值时，我们并没有使用任何从 Dota2 得到的英雄属性信息。<br>我们可以将 Dota2 英雄的选派看作是我们不会说的一门外语。通过观察这些词的使用模式，找出词意相近的词语。<br>进一步地，通过连接在无监督学习下得到的分类特征，我们能够解释这些潜在属性。</p>
<hr>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://federicov.github.io/word-embeddings-and-dota2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《 Gavagai 》&lt;/a&gt;   原文
    
    </summary>
    
      <category term="翻译" scheme="http://VectorF.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="机器学习" scheme="http://VectorF.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="http://VectorF.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="dota2" scheme="http://VectorF.github.io/tags/dota2/"/>
    
      <category term="自然语言处理" scheme="http://VectorF.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="词向量" scheme="http://VectorF.github.io/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程</title>
    <link href="http://VectorF.github.io/2016/11/06/20161106-Git%20%E6%95%99%E7%A8%8B/"/>
    <id>http://VectorF.github.io/2016/11/06/20161106-Git 教程/</id>
    <published>2016-11-06T12:30:30.000Z</published>
    <updated>2016-11-06T13:18:39.198Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="http://ofa07l4yq.bkt.clouddn.com/git.jpg" alt="git"><br><br></div>

<blockquote>
<p>本 Git 教程根据<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a> 整理总结而来，其中代码和说明均来源于廖大神，非原创。</p>
</blockquote>
<h2 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a><strong>安装后的配置</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a><strong>创建版本库</strong></h2><p>1.创建新的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir gittest</div><div class="line">$ cd ngittest</div><div class="line">$ pwd</div></pre></td></tr></table></figure>
<p><code>mkdir</code>创建新目录，<code>cd</code>定位到该目录，<code>pwd</code>显示当前目录。</p>
<p>2.<code>git init</code>将该目录编程git可以管理的仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ ls -ah</div></pre></td></tr></table></figure>
<p>3.把文件添加到版本库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m &quot;wrote a readme flie&quot;</div></pre></td></tr></table></figure>
<p>4.查看仓库的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git status</div></pre></td></tr></table></figure>
<p>5.查看更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff</div></pre></td></tr></table></figure>
<p>6.查看提交历史记录，按<code>q</code>可退出该命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git log</div><div class="line">$ git log --pretty=oneline</div></pre></td></tr></table></figure>
<p>7.查看命令历史记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div></pre></td></tr></table></figure>
<p>8.版本回退及撤销回退</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard HEAD^^</div><div class="line">$ cat readme.txt</div><div class="line">$ git reset --hard commit_id</div></pre></td></tr></table></figure>
<p>**注意：原教程中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>；但在实际中，貌似<code>HEAD^</code>是当前版本，<code>HEAD^^</code>是恢复到上一个版本。</p>
<p>9.对比工作区和版本库中的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff HEAD^ -- readme.txt</div></pre></td></tr></table></figure>
<p>10.撤销修改</p>
<ul>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
</ul>
<p>对readme.txt进行修改后，使用<code>git checkout -- file</code>丢弃工作区的修改。这里有两种情况：</p>
<p>一种是<code>README.md</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>README.md</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- readme.txt</div></pre></td></tr></table></figure>
<ul>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD^ readme.txt</div><div class="line">$ git checkout -- readme.txt</div></pre></td></tr></table></figure>
<ul>
<li>已经提交了不合适的修改到版本库时，想要撤销本次提交，可使用版本回退，不过前提是没有推送到远程库。</li>
</ul>
<p>11.删除文件</p>
<p>删除工作区的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm test.txt</div></pre></td></tr></table></figure>
<ul>
<li>如果需要在版本库中也删除该文件，使用<code>git rm</code>，并且<code>git commit</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git rm test.txt</div><div class="line">$ git commit -m &quot;remove test.txt&quot;</div></pre></td></tr></table></figure>
<ul>
<li>如果是在工作区误删了文件，则需通过版本库恢复到最新版本。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout --test.txt</div></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a><strong>远程仓库</strong></h2><p>1.创建 SSH key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</div></pre></td></tr></table></figure>
<p>在用户主目录中找到<code>id_rsa.pub</code>，粘贴进 Github。</p>
<p>2.添加远程库</p>
<p>先在 Github 上创建一个仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:yourusername/gittest.git</div></pre></td></tr></table></figure>
<p>**注意：远程库的名字就是<code>origin</code>，也可改成别的，但一般用<code>origin</code>。</p>
<p>将本地库的内容推送到远程库上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<p>第一次推送<code>master</code>分支时，要用<code>-u</code>参数。之后就可以只用<code>git push origin master</code></p>
<p>3.从远程库克隆</p>
<p>先在 Github 上创建一个新的仓库，名字叫<code>gitskills</code>。</p>
<p>用命令<code>git clone</code>克隆一个本地库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github.com:yourusername/gitskills.git</div><div class="line">$ cd gitskills</div><div class="line">$ ls</div></pre></td></tr></table></figure>
<p>**注意：Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h2><p>1.创建与合并分支</p>
<ul>
<li>创建<code>dev</code>分支，并切换到<code>dev</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch &apos;dev&apos;</div></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line">$ git checkout dev</div><div class="line">Switched to branch &apos;dev&apos;</div></pre></td></tr></table></figure>
<ul>
<li>然后，用<code>git branch</code>命令查看当前分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* dev</div><div class="line">  master</div></pre></td></tr></table></figure>
<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<ul>
<li>之后就可以在<code>dev</code>分支上正常提交，比如对README.md做个修改，加上一行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick.</div></pre></td></tr></table></figure>
<p>然后提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;branch test&quot;</div></pre></td></tr></table></figure>
<ul>
<li>切换回<code>master</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div></pre></td></tr></table></figure>
<p>再查看 README.md 文件，刚才添加的内容不见了。因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变</p>
<ul>
<li>把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge dev</div><div class="line">Updating ********</div><div class="line">Fast-forward</div><div class="line"> README.md | 4 +++-</div><div class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</div></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看 README.md 的内容，可看到和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>**注意：上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。并非每次合并都能<code>Fast-forward</code>。</p>
<ul>
<li>合并后，可删除<code>dev</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -d dev</div><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure>
<p>2.解决冲突</p>
<ul>
<li>准备新的<code>feature1</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature1</div></pre></td></tr></table></figure>
<p>修改README.md最后一行，改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick AND simple.</div></pre></td></tr></table></figure>
<p>在<code>featrure1</code>分支上提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;AND simple&quot;</div></pre></td></tr></table></figure>
<ul>
<li>切换到<code>master</code>分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</div></pre></td></tr></table></figure>
<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把README.md的最后一行改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick &amp; simple.</div></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md </div><div class="line">$ git commit -m &quot;&amp; simple&quot;</div></pre></td></tr></table></figure>
<ul>
<li>合并</li>
</ul>
<p>若直接使用<code>marge</code>命令，会产生冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge freature1</div><div class="line">Auto-merging README.md</div><div class="line">CONFLICT (content): Merge conflict in README.md</div><div class="line">Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>
<p><code>git status</code>命令可告诉我们冲突的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 2 commits.</div><div class="line">  (use &quot;git push&quot; to publish your local commits)</div><div class="line">You have unmerged paths.</div><div class="line">  (fix conflicts and run &quot;git commit&quot;)</div><div class="line">  (use &quot;git merge --abort&quot; to abort the merge)</div><div class="line"></div><div class="line">Unmerged paths:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</div><div class="line"></div><div class="line">        both modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div></pre></td></tr></table></figure>
<p>此时，直接查看README.md中的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># gitskills</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">Creating a new branch is quick &amp; simple.</div><div class="line">=======</div><div class="line">Creating a new branch is quick AND simple.</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</div></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick and simple.</div></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;conflict fixed&quot;</div></pre></td></tr></table></figure>
<p>用带参数的<code>git log</code>可看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div></pre></td></tr></table></figure>
<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature1</div></pre></td></tr></table></figure>
<ul>
<li><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
</li>
</ul>
<p>3.分支策略管理</p>
<p>通常，Git 会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢失分支信息。</p>
<p>如果强制禁用<code>Fast forward</code>模式，Git 就会在merge时生成一个新的commit，这样分支历史上就可看到分支信息。</p>
<p>实际开发中，<code>master</code>分支应当是稳定的，仅用来发布新版本，平时不在上面干活；</p>
<p>而<code>dev</code>分支是不稳定的，在这上面干活。等到新版本需要发布时，把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支上发布新版本。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<ul>
<li>使用<code>--no-ff</code>方式的<code>git merge</code></li>
</ul>
<p>首先，创建并切换<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div></pre></td></tr></table></figure>
<p>修改README.md文件，并提交一个新的commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;add merge&quot;</div></pre></td></tr></table></figure>
<p>接下来，切换回<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout merge</div></pre></td></tr></table></figure>
<p>使用<code>--no-ff</code>参数（表示禁用<code>Fast forward</code>）合并<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</div></pre></td></tr></table></figure>
<p>**注意：因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，用<code>git log</code>查看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div><div class="line">*   f808280 merge with no-ff</div><div class="line">|\</div><div class="line">| * 081f9ca add merge</div><div class="line">|/</div><div class="line">*   fe3d2cc conflict fixed</div></pre></td></tr></table></figure>
<p>4.Bug 分支</p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p>假定此时需要创建一个分支<code>issue-101</code>来修复代号101的bug的任务。</p>
<p>Git 提供一个<code>stash</code>功能，把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash</div></pre></td></tr></table></figure>
<p>现在用<code>git status</code>查看工作区，就是干净的。</p>
<ul>
<li>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git checkout -b issue-101</div></pre></td></tr></table></figure>
<p>现在修复bug，任意修改README.md ，然后提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;fix bug 101&quot;</div></pre></td></tr></table></figure>
<ul>
<li>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line">$ git branch -d issue-101</div></pre></td></tr></table></figure>
<ul>
<li>回到<code>dev</code>分支干活：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div><div class="line">$ git status</div></pre></td></tr></table></figure>
<p>工作区是干净的，用<code>git stash list</code>命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div></pre></td></tr></table></figure>
<p>有两种方法恢复工作区：</p>
<ul>
<li>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li>
<li>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash pop</div></pre></td></tr></table></figure>
<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div></pre></td></tr></table></figure>
<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash apply stash@&#123;0&#125;</div></pre></td></tr></table></figure>
<p>5.Feature 分支</p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D</code>强行删除。</p>
<ul>
<li>假设需添加一个开发代号为Vulcan的新功能。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature-vulcan</div><div class="line">$ git add vulcan.py</div><div class="line">$ git commit -m &quot;add feature vulcan&quot;</div></pre></td></tr></table></figure>
<p>切回<code>dev</code>，准备合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<p>如果此时必须销毁该<code>feature-vulcan</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature-vulcan</div><div class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</div><div class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</div></pre></td></tr></table></figure>
<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令<code>git branch -D feature-vulcan</code>。</p>
<p>现在，强行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -D feature-vulcan</div></pre></td></tr></table></figure>
<p>6.多人协作</p>
<p>多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to=origin/&lt;branch&gt; dev</code>。</p>
<ul>
<li>实际上，从远程仓库克隆时 Git 自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</li>
</ul>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote</div></pre></td></tr></table></figure>
<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin  git@github.com:yourusername/gittest.git (fetch)</div><div class="line">origin  git@github.com:yourusername/gittest.git (push)</div></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<ul>
<li>推送分支：把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<p><code>master</code>分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p><code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<ul>
<li>抓取分支</li>
</ul>
<p>模拟一个小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github.com:yourusername/gittest.git</div></pre></td></tr></table></figure>
<p>从远程库clone时，默认情况下只能看到本地的<code>master</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure>
<p>要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev origin/dev</div></pre></td></tr></table></figure>
<p>现在就可以在<code>dev</code>上继续修改。然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;add devtest.txt&quot;</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add devtest.txt</div><div class="line">$ git commit -m &quot;add aaa&quot;</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<p>推送失败。解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull</div></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接，再 pull ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch --set-upstream-to=origin/dev dev</div><div class="line">$ git pull</div></pre></td></tr></table></figure>
<p>**注意：原教程中使用的是<code>git branch --set-upstream dev origin/&lt;branch&gt;</code>命令。</p>
<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的”解决冲突”完全一样。解决后，提交，再push：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;merge &amp; fix devtest.txt&quot;</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a><strong>标签管理</strong></h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），标签也是版本库的一个快照。</p>
<p>标签是指向某个 commit 的指针（和分支相似，但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p>
<p>1.创建标签</p>
<p>首先，切换到需要到打标签的分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">$ git checkout master</div></pre></td></tr></table></figure>
<p>然后，命令<code>git tag</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id。</p>
<p>敲命令<code>git tag</code>就可以打一个新标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.0</div></pre></td></tr></table></figure>
<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v1.0</div></pre></td></tr></table></figure>
<p>默认标签是打在最新提交的commit上的。如果需要对当前时间之前的 commit 打标签，就需要找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git log --pretty=oneline --abbrev-commit</div><div class="line">477debf add test.txt</div><div class="line">5b24428 git tracks changes of files</div><div class="line">2367db6 git tracks changes</div><div class="line">29f5a3c understand how stage works</div><div class="line">e5f00d8 append gpl</div><div class="line">64106a2 add distributed</div><div class="line">2a9a448 wtrote a readme file</div></pre></td></tr></table></figure>
<p>比方说要对<code>git tracks changes of files</code>这次提交打标签，它对应的commit id是<code>5b24428</code>，敲入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v0.9 5b24428</div></pre></td></tr></table></figure>
<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v0.9</div><div class="line">v1.0</div></pre></td></tr></table></figure>
<p>**注意：标签不是按时间顺序列出，而是按字母排序的。</p>
<p>可以用<code>git show</code>查看标签信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v0.9</div></pre></td></tr></table></figure>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 2a9a448</div></pre></td></tr></table></figure>
<p>用命令<code>git show</code>可以看到说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v0.1</div></pre></td></tr></table></figure>
<p>还可以通过<code>-s</code>用私钥签名一个标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; 64106a2</div></pre></td></tr></table></figure>
<p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gpg: signing failed: secret key not available</div><div class="line">error: gpg failed to sign the data</div><div class="line">error: unable to sign the tag</div></pre></td></tr></table></figure>
<p>如果报错，请参考GnuPG帮助文档配置Key。</p>
<p>用命令<code>git show</code>可以看到PGP签名信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v0.2</div></pre></td></tr></table></figure>
<p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名。</p>
<p>2.操作标签</p>
<p>删除标签，使用命令<code>git tag -d &lt;tagname&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -d v0.1</div></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或者一次性推送全部尚未推送到远程的本地标签，使用命令<code>git push origin --tags</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.0</div><div class="line">$ git push origin --tags</div></pre></td></tr></table></figure>
<p>如果标签已经推送到远程，先从本地删除，再从远程删除，使用命令<code>git push origin :refs/tags/</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -d v0.9</div><div class="line">$ git push origin :refs/tags/v0.9</div></pre></td></tr></table></figure>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a><strong>Github</strong></h2><p>访问想要 Fork 的仓库，在自己的账号下克隆，然后使用<code>git clone &lt;address&gt;</code>命令 clone 到本地进行修改。</p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h2 id="自定义-Git"><a href="#自定义-Git" class="headerlink" title="自定义 Git"></a><strong>自定义 Git</strong></h2><p>在“安装Git”一节中，已经配置了<code>user.name</code>和<code>user.email</code>。</p>
<p>如果想让 Git 显示颜色，让命令输出看起来更醒目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global color.ui true</div></pre></td></tr></table></figure>
<p>1.忽略特殊文件</p>
<ul>
<li>忽略某些文件时，需要编写<code>.gitignore</code>；</li>
<li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li>
</ul>
<p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p><code>.gitignore</code>文件内容的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># Windows:</div><div class="line">Thumbs.db</div><div class="line">ehthumbs.db</div><div class="line">Desktop.ini</div><div class="line"></div><div class="line"># Python:</div><div class="line">*.py[cod]</div><div class="line">*.so</div><div class="line">*.egg</div><div class="line">*.egg-info</div><div class="line">dist</div><div class="line">build</div><div class="line"></div><div class="line"># My configurations:</div><div class="line">db.ini</div><div class="line">deploy_key_rsa</div></pre></td></tr></table></figure>
<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>在 Windows 环境下，如果在资源管理器里新建一个<code>.gitignore</code>文件，它会提示必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add App.class</div><div class="line">The following paths are ignored by one of your .gitignore files:</div><div class="line">App.class</div><div class="line">Use -f if you really want to add them.</div></pre></td></tr></table></figure>
<p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add -f App.class</div></pre></td></tr></table></figure>
<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git check-ignore -v App.class</div><div class="line">.gitignore:3:*.class    App.class</div></pre></td></tr></table></figure>
<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p>2.配置别名</p>
<p>如果想敲<code>git st</code>就可以表示<code>git status</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure>
<p>当然可以用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.co checkout</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.br branch</div></pre></td></tr></table></figure>
<p>以后提交就可以简写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git ci -m &quot;bala bala bala...&quot;</div></pre></td></tr></table></figure>
<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>用<code>unstage</code>表示<code>reset HEAD</code>，把暂存区的修改撤销掉（unstage），重新放回工作区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</div></pre></td></tr></table></figure>
<p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.last &apos;log -1&apos;</div></pre></td></tr></table></figure>
<p>把<code>lg</code>配置成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure>
<ul>
<li>配置文件</li>
</ul>
<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ cat .git/config </div><div class="line">[core]</div><div class="line">    repositoryformatversion = 0</div><div class="line">    filemode = true</div><div class="line">    bare = false</div><div class="line">    logallrefupdates = true</div><div class="line">    ignorecase = true</div><div class="line">    precomposeunicode = true</div><div class="line">[remote &quot;origin&quot;]</div><div class="line">    url = git@github.com:yourusername/gittest.git</div><div class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">[branch &quot;master&quot;]</div><div class="line">    remote = origin</div><div class="line">    merge = refs/heads/master</div><div class="line">[alias]</div><div class="line">    last = log -1</div></pre></td></tr></table></figure>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat .gitconfig</div><div class="line">[alias]</div><div class="line">    co = checkout</div><div class="line">    ci = commit</div><div class="line">    br = branch</div><div class="line">    st = status</div><div class="line">[user]</div><div class="line">    name = Your Name</div><div class="line">    email = your@email.com</div></pre></td></tr></table></figure>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<p>3.搭建 Git 服务器</p>
<p>等我装个 ubuntu 再试试……</p>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ofa07l4yq.bkt.clouddn.com/git.jpg&quot; alt=&quot;git&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本 Git 教程根据&lt;a href=
    
    </summary>
    
      <category term="教程" scheme="http://VectorF.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="http://VectorF.github.io/tags/Git/"/>
    
      <category term="教程" scheme="http://VectorF.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>永不过时的 K 均值算法</title>
    <link href="http://VectorF.github.io/2016/10/21/20161021-Translate-K-Means/"/>
    <id>http://VectorF.github.io/2016/10/21/20161021-Translate-K-Means/</id>
    <published>2016-10-21T13:27:17.000Z</published>
    <updated>2017-02-21T03:57:32.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://quantdare.com/2016/04/k-means-vs-k-medoids/" target="_blank" rel="external">《”K-Means never fails”, they said…》</a> &ensp; 原文作者：Fjrodriguez2</p>
<p>译文于 2016/09/14 发表在 <a href="http://datartisan.com/article/detail/168.html" target="_blank" rel="external">数据工匠</a> 网站中</p>
</blockquote>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>众所周知，数据挖掘算法并非十全十美，在某些情况下他们也会失效。 使用 K 均值算法（K-Means）时就可能会出现这种情况，当然此时你可以尝试一下另一种方法—— K 中心聚类算法（K-Medoids），也许效果会更好。</p>
<p>在该网站之前的文章《揭开机器学习的面纱》中，已经指出， K 均值算法用于聚类时效果良好，而且在数据挖掘和机器学习领域，它也有着重要的地位。Psanchezcri 就曾在他的文章《将 K 均值方法用于金融时序回报率聚类》中，将 K 均值算法用于分析金融时间序列的趋势。</p>
<p>然而，即使在网络上有关算法的文档浩如烟海的情况下，关于机器学习算法有时会失效的讨论却并不多见。</p>
<p>因此，本文借由一个金融案例来反映这个问题。</p>
<hr>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>1）首先，我们在欧洲斯托克600指数的成分股中选择三组共6只股票（在三个不同的部门中各选两只）：</p>
<ul>
<li><p>金融部门：  西班牙毕尔巴鄂比斯开银行 &amp; 桑坦德银行</p>
</li>
<li><p>非必需消费品：  法国酩悦·轩尼诗－路易·威登 &amp; 迪奥</p>
</li>
<li><p>能源部门：  英国石油公司 &amp; 锡尼什港能源公司</p>
</li>
</ul>
<p>2）搜集数据，并绘出在2013/01/01至2015/12/31期间这六只股票的价格走势曲线。如下所示：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/1.png" alt="1"><br></div>


<p>3）选择日回报率作为计算指标，我们算出三组股票序列的相关距离。然后通过距离矩阵降维的方法，在二维欧氏空间中绘出每个点。</p>
<p>结果显示这六只股票可以按部门进行分类效果显著。下图以蓝色菱形点、绿色正方形点、红色圆点来标记六只股票，明显可以按部门分为三类：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/2.png" alt="2"><br></div>


<p>4）最后，我们将 K 均值算法运用于距离矩阵，聚类目标预先设定分成3类。由于 K 均值算法是从随机点开始的，每次运行结果可能有所不同，本文我们预先设定运行这个算法15次，即产生15个结果。当然，我们希望得到聚类结果符合股票所属部门的实际情况。</p>
<hr>
<h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>１）在约80%的聚类结果中，K 均值聚类算法取得了理想的结果，聚类结果与这六只股票所属部门相符，如下图所示：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/3.png" alt="3"><br></div>


<p>２）在剩下的20%的聚类结果中，算法则出现了聚类的错误。例如，下图中错将两个不同部门的四只股票聚为一类（图中蓝色菱形点和绿色正方形点），而将同一部门的两只股票分为两类（图中红色圆点）：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/4.png" alt="4"><br></div>


<p>如果我们使用与之思想类似的 K 中心聚类算法，结果则可以达到100%的正确聚类率。这表明在聚类时，似乎使用重心会比用均值来衡量距离，效果更好。</p>
<hr>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://quantdare.com/2016/04/k-means-vs-k-medoids/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《”K-Means never fails”, the
    
    </summary>
    
      <category term="翻译" scheme="http://VectorF.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="K均值" scheme="http://VectorF.github.io/tags/K%E5%9D%87%E5%80%BC/"/>
    
      <category term="聚类" scheme="http://VectorF.github.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="http://VectorF.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="http://VectorF.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博文</title>
    <link href="http://VectorF.github.io/2016/10/19/20161019-my-first-post/"/>
    <id>http://VectorF.github.io/2016/10/19/20161019-my-first-post/</id>
    <published>2016-10-19T05:31:17.000Z</published>
    <updated>2016-10-19T13:18:13.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello,world!"></a>Hello,world!</h2><p><a id="more"></a>你好呀！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hello-world&quot;&gt;&lt;a href=&quot;#Hello-world&quot; class=&quot;headerlink&quot; title=&quot;Hello,world!&quot;&gt;&lt;/a&gt;Hello,world!&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://VectorF.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="http://VectorF.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
