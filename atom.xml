<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vector Blog</title>
  <subtitle>Vector Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vectorf.github.io/"/>
  <updated>2018-01-31T13:28:59.739Z</updated>
  <id>https://vectorf.github.io/</id>
  
  <author>
    <name>VectorF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在树莓派上编译安装 OpenCV</title>
    <link href="https://vectorf.github.io/2018/01/31/20180131-%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-OpenCV/"/>
    <id>https://vectorf.github.io/2018/01/31/20180131-在树莓派上编译安装-OpenCV/</id>
    <published>2018-01-31T13:18:56.000Z</published>
    <updated>2018-01-31T13:28:59.739Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>本次使用的树莓派版本为 <strong>Raspberry Pi 3 Model B</strong>，搭载 <strong>Raspbian</strong> 系统</li>
<li><strong>OpenCV</strong> 版本为 3.1.0</li>
<li><strong>Python</strong> 版本为 3.5</li>
</ul>
<p>参考博客为：<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" title="Install guide: Raspberry Pi 3 + Raspbian Jessie + OpenCV 3" target="_blank" rel="external">Install guide: Raspberry Pi 3 + Raspbian Jessie + OpenCV 3</a></p>
<hr>
<p>开始之前，请先确保你可以连接上树莓派，下面两种方式可以二选一：</p>
<ul>
<li>将树莓派连接上一个显示器，直接在命令行中操作</li>
<li>通过 ssh 方式登陆连接上树莓派</li>
</ul>
<hr>
<h2 id="1-扩展可用空间（可选）"><a href="#1-扩展可用空间（可选）" class="headerlink" title="1. 扩展可用空间（可选）"></a>1. 扩展可用空间（可选）</h2><p>如果使用的是一个崭新的树莓派，可以通过扩展可用空间的方式确保储存空间够用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo raspi-config</div></pre></td></tr></table></figure>
<p>选择第一个选项 <strong>1. Expand Filesystem</strong>，回车确认后，跳转至 <strong>Finish</strong> 结束即可。</p>
<p>由于系统版本问题，笔者的该选项卡是在 <strong>Advanced Options</strong> 下的。</p>
<p>之后重启树莓派：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo reboot</div></pre></td></tr></table></figure>
<p>还可以通过卸载 Wolfram engine 获得更多的可用空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get purge wolfram-engine</div></pre></td></tr></table></figure>
<hr>
<h2 id="2-安装依赖项"><a href="#2-安装依赖项" class="headerlink" title="2. 安装依赖项"></a>2. 安装依赖项</h2><h3 id="2-1-升级现有包"><a href="#2-1-升级现有包" class="headerlink" title="2.1 升级现有包"></a>2.1 升级现有包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get upgrade</div></pre></td></tr></table></figure>
<h3 id="2-2-安装编译工具"><a href="#2-2-安装编译工具" class="headerlink" title="2.2 安装编译工具"></a>2.2 安装编译工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install build-essential cmake pkg-config</div></pre></td></tr></table></figure>
<h3 id="2-3-安装图像和视频相关接口包"><a href="#2-3-安装图像和视频相关接口包" class="headerlink" title="2.3 安装图像和视频相关接口包"></a>2.3 安装图像和视频相关接口包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install libjpeg-dev libtiff5-dev libjasper-dev libpng12-dev</div><div class="line">$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</div><div class="line">$ sudo apt-get install libxvidcore-dev libx264-dev</div></pre></td></tr></table></figure>
<h3 id="2-4-安装-GTK-库，用以编译-OpenCV-中的-highgui-模块"><a href="#2-4-安装-GTK-库，用以编译-OpenCV-中的-highgui-模块" class="headerlink" title="2.4 安装 GTK 库，用以编译 OpenCV 中的 highgui 模块"></a>2.4 安装 GTK 库，用以编译 OpenCV 中的 highgui 模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install libgtk2.0-dev</div></pre></td></tr></table></figure>
<h3 id="2-5-安装加速-OpenCV-运算的额外包"><a href="#2-5-安装加速-OpenCV-运算的额外包" class="headerlink" title="2.5 安装加速 OpenCV 运算的额外包"></a>2.5 安装加速 OpenCV 运算的额外包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install libatlas-base-dev gfortran</div></pre></td></tr></table></figure>
<h3 id="2-6-安装-python-头文件"><a href="#2-6-安装-python-头文件" class="headerlink" title="2.6 安装 python 头文件"></a>2.6 安装 python 头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install python2.7-dev python3.5-dev</div></pre></td></tr></table></figure>
<hr>
<h2 id="3-下载-OpenCV-源代码"><a href="#3-下载-OpenCV-源代码" class="headerlink" title="3. 下载 OpenCV 源代码"></a>3. 下载 OpenCV 源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.1.0.zip</div><div class="line">$ unzip opencv.zip</div><div class="line"></div><div class="line">$ wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip</div><div class="line">$ unzip opencv_contrib.zip</div></pre></td></tr></table></figure>
<p><em>注：</em>请务必保证 OpenCV 和 OpenCV_Contrib 的版本一致</p>
<hr>
<h2 id="4-选择-python-版本，并创建新环境-（可选）"><a href="#4-选择-python-版本，并创建新环境-（可选）" class="headerlink" title="4. 选择 python 版本，并创建新环境 （可选）"></a>4. 选择 python 版本，并创建新环境 （可选）</h2><p>参考博客的教程中使用 <strong>virtualenv  &amp; virtualenvwrapper</strong> 工具在系统的 python 下创建了新的环境，用以编译安装 OpenCV，感兴趣的话可以跳转至 <a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" title="Install guide: Raspberry Pi 3 + Raspbian Jessie + OpenCV 3" target="_blank" rel="external">该教程</a> 进行查看。</p>
<p>本次，笔者直接在系统 python ( python = 3.5 )的环境下直接编译安装 OpenCV，因此这一步可以省略，不过需要保证该 python 环境下已有 <strong>numpy</strong> 库和 <strong>pip</strong> 库。</p>
<hr>
<h2 id="5-编译安装-OpenCV"><a href="#5-编译安装-OpenCV" class="headerlink" title="5. 编译安装 OpenCV"></a>5. 编译安装 OpenCV</h2><h3 id="5-1-定位到-OpenCV-源代码文件下，并使用-CMake-进行编译："><a href="#5-1-定位到-OpenCV-源代码文件下，并使用-CMake-进行编译：" class="headerlink" title="5.1 定位到 OpenCV 源代码文件下，并使用 CMake 进行编译："></a>5.1 定位到 OpenCV 源代码文件下，并使用 CMake 进行编译：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ cd ~/opencv-3.1.0/</div><div class="line">$ mkdir build</div><div class="line">$ cd build</div><div class="line">$ cmake -D CMAKE_BUILD_TYPE=RELEASE \</div><div class="line">    -D INSTALL_PYTHON_EXAMPLES=ON \</div><div class="line">    -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.1.0/modules \</div><div class="line">    -D BUILD_EXAMPLES=ON \</div><div class="line">	-D WITH_CUDA=OFF \</div><div class="line">	-D BUILD_TESTS=OFF \</div><div class="line">	-D CMAKE_INSTALL_PREFIX=/usr/local \</div><div class="line">	-D BUILD_DOCS=OFF \</div><div class="line">	-D ENABLE_PRECOMPILED_HEADERS=OFF \</div><div class="line">	-D WITH_OPENMP=ON </div><div class="line">	-D PYTHON_DEFAULT_EXECUTABLE=/usr/bin/python3 ..</div></pre></td></tr></table></figure>
<p>顺利的话，在 CMake 的输出里可以看到 python3 的 <strong>Interpreter</strong> 、<strong>Libraries</strong> 、<strong>numpy</strong> 、<strong>packages path</strong> 路径均正常。</p>
<h3 id="5-2-编译-OpenCV"><a href="#5-2-编译-OpenCV" class="headerlink" title="5.2 编译 OpenCV"></a>5.2 编译 OpenCV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make -j4</div></pre></td></tr></table></figure>
<p><code>-j4</code> 指的是使用 4 核。</p>
<p>这个过程会持续较长的时间。</p>
<h3 id="5-3-如有意外"><a href="#5-3-如有意外" class="headerlink" title="5.3 如有意外"></a>5.3 如有意外</h3><p>如果脸不黑的话，<code>make</code> 将会顺利结束。但如果有错误发生的话，需要清除当前编译的结果，重新编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make clean</div></pre></td></tr></table></figure>
<p>特别是，多核编译时，可能会出错。可尝试单核编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make</div></pre></td></tr></table></figure>
<p>当然，也有可能是其他错误导致的，这就需要你耐心检查谷歌去解决。</p>
<h3 id="5-4-安装-OpenCV"><a href="#5-4-安装-OpenCV" class="headerlink" title="5.4 安装 OpenCV"></a>5.4 安装 OpenCV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo make install</div><div class="line">$ sudo ldconfig</div></pre></td></tr></table></figure>
<hr>
<h2 id="6-安装-OpenCV-的收尾工作（可选）"><a href="#6-安装-OpenCV-的收尾工作（可选）" class="headerlink" title="6. 安装 OpenCV 的收尾工作（可选）"></a>6. 安装 OpenCV 的收尾工作（可选）</h2><p>对于 python3：</p>
<p>在成功运行 <code>make install</code> 之后，OpenCV 与 python3 的链接应当安装在了 <code>/usr/local/lib/python3.5/dist-packages</code> ，你可以使用 <code>ls</code> 命令确认：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls -l /usr/local/lib/python3.5/dist-packages/</div></pre></td></tr></table></figure>
<p>但是输出的 <code>.so</code> 文件名并非是 <code>cv2.so</code> ，而是 <code>cv2.cpython-35m-arm-linux-gnueabinf.so</code> ，还需要做一点小调整（ <del>非必须</del> ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /usr/local/lib/python3.5/dist-packages/</div><div class="line">$ sudo mv cv2.cpython-35m-arm-linux-gnueabinf.so cv2.so</div></pre></td></tr></table></figure>
<hr>
<h2 id="7-确认-OpenCV-成功安装"><a href="#7-确认-OpenCV-成功安装" class="headerlink" title="7. 确认 OpenCV 成功安装"></a>7. 确认 OpenCV 成功安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ python3</div><div class="line">&gt;&gt;&gt; import cv2</div><div class="line">&gt;&gt;&gt; cv2.__version__</div><div class="line">&apos;3.1.0&apos;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考博客：<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" title="Install guide: Raspberry Pi 3 + Raspbian Jessie + OpenCV 3" target="_blank" rel="external">Install guide: Raspberry Pi 3 + Raspbian Jessie + OpenCV 3</a><br>转载请注明来自 <a href="https://vectorf.github.io">Vector Blog</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本次使用的树莓派版本为 &lt;strong&gt;Raspberry Pi 3 Model B&lt;/strong&gt;，搭载 &lt;strong&gt;Raspbian&lt;/strong&gt; 系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OpenCV&lt;/strong&gt; 版本为 3.1.0&lt;/li&gt;
    
    </summary>
    
      <category term="Python" scheme="https://vectorf.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="树莓派" scheme="https://vectorf.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="OpenCV" scheme="https://vectorf.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>初探 RSelenium —— 基于豆瓣电影的爬虫实例</title>
    <link href="https://vectorf.github.io/2017/07/10/20170710-%E5%88%9D%E6%8E%A2RSelenium/"/>
    <id>https://vectorf.github.io/2017/07/10/20170710-初探RSelenium/</id>
    <published>2017-07-10T15:32:08.000Z</published>
    <updated>2018-01-31T14:57:49.899Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <a href="https://cran.r-project.org/web/packages/RSelenium/vignettes/RSelenium-basics.html" target="_blank" rel="external">RSelenium</a> 包可通过 R 实现对浏览器的自动控制，完成诸如“点击”，“输入”等操作，从而爬取动态页面，解放你的双手！ </p>
<p>本文基于 <a href="https://movie.douban.com" target="_blank" rel="external">豆瓣电影</a> 网站的爬虫实例， 对 <a href="https://cran.r-project.org/web/packages/RSelenium/vignettes/RSelenium-basics.html" target="_blank" rel="external">RSelenium</a> 包的使用做了初步的介绍。</p>
<hr>
<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul>
<li>JAVA：安装 JAVA</li>
<li>Selenium Server：下载 selenium-server-standalone-版本号.jar （本文使用的是 3.4.0 版本）</li>
<li>Chrome：安装 Chrome</li>
<li><p>ChromeDriver：下载 chromedrive.exe</p>
<p><em>注：</em>下载的 chromedriver.exe 需放置在 Chrome 浏览器的安装目录下，即和 chrome.exe 放在同一个文件目录下。并将该目录添加入 <strong>环境变量</strong> 中。</p>
</li>
</ul>
<p>一般 Chrome 的默认安装路径为：C:\Program Files (x86)\Google\Chrome\Application 。</p>
<div align="center"><br><br><img src="1.png" alt="1"><br><br></div>

<ul>
<li>SelectorGadget ：[ <del>非必需</del> ] Chrome 扩展，可用于定位网页元素的 xpath 。不过，也可以用 Chrome 浏览器在网页右键选项卡中的“检查” 功能（快捷键：F12）。 </li>
<li>所需 R 包：<br><code>RSelenium</code> 包：实现对浏览器行为的自动控制<br><code>rvest</code> 包：读取网页，定位网页元素并提取文本<br><code>stringr</code> 包：利用正则表达式进行字符串处理</li>
</ul>
<hr>
<h2 id="Let’s-do-it"><a href="#Let’s-do-it" class="headerlink" title="Let’s do it !"></a>Let’s do it !</h2><p>本文以“鹿晗”作为关键词（ <del>真爱粉们不要太较真</del> ），搜索其出演过的电影，最终整理出电影名、评分信息和评价人数表。</p>
<h3 id="1-启动-Selenium-Server"><a href="#1-启动-Selenium-Server" class="headerlink" title="1. 启动 Selenium Server"></a>1. 启动 Selenium Server</h3><p>在所下载的 selenium-server-standalone-3.4.0.jar 文件目录下打开命令行，输入以下命令以启动Selenium Server ：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar selenium-server-standalone-3.4.0.jar</div></pre></td></tr></table></figure>
<p>你也可以把这个命令存成后缀为 <code>.cmd</code> 的文件放在该文件目录下，这样下次只需双击运行即可。</p>
<hr>
<h3 id="2-在-R-中连接-Server-，打开浏览器和目标网页"><a href="#2-在-R-中连接-Server-，打开浏览器和目标网页" class="headerlink" title="2. 在 R 中连接 Server ，打开浏览器和目标网页"></a>2. 在 R 中连接 Server ，打开浏览器和目标网页</h3>  <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 载入包</span></div><div class="line"><span class="keyword">library</span>(RSelenium)</div><div class="line"><span class="keyword">library</span>(rvest)</div><div class="line"><span class="keyword">library</span>(stringr)</div><div class="line"><span class="comment"># 连接 Server</span></div><div class="line">remDr &lt;- remoteDriver(remoteServerAddr = <span class="string">"127.0.0.1"</span> ,</div><div class="line">	port = <span class="number">4444</span>,</div><div class="line">	browserName = <span class="string">"chrome"</span></div><div class="line">)</div><div class="line"><span class="comment"># 打开浏览器</span></div><div class="line">remDr$open()</div><div class="line"><span class="comment"># 打开目标网页</span></div><div class="line">remDr$navigate(<span class="string">"https://movie.douban.com/"</span>)</div></pre></td></tr></table></figure>
<p>是不是发现，运行代码后自动启动了 Chrome ，并打开了 <a href="https://movie.douban.com" target="_blank" rel="external">豆瓣电影</a> ？！有没有一点紧张和小刺激？！😎</p>
<hr>
<h3 id="3-定位网页元素，并向其传入参数"><a href="#3-定位网页元素，并向其传入参数" class="headerlink" title="3. 定位网页元素，并向其传入参数"></a>3. 定位网页元素，并向其传入参数</h3><p> <code>RSelenium</code> 包可通过 <code>name</code> 、 <code>id</code> 、 <code>class</code> 、 <code>css-selectors</code> 、 <code>xpath</code> 对网页元素进行定位。本文尽可能多地采取不同的方法来展示如何使用它们。</p>
<div align="center"><br><br><img src="2.png" alt="2"><br><br></div>

<p>可以看到，我们需要定位到搜索框。使用 SelectorGadget 或者浏览器的“检查”功能，得到该搜索框的 <code>name</code> 为 <code>search_text</code> 。</p>
<p>在定位到搜索框后，需要传入 <code>keyword</code> 并”回车“，从而实现搜索。</p>
<ul>
<li><p><code>findElement</code> ：定位符合条件的网页元素 </p>
</li>
<li><p><code>sendKeysToElement</code> ：传入参数</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置搜索词</span></div><div class="line">keyword&lt;- <span class="string">"鹿晗"</span></div><div class="line"><span class="comment"># 定位网页元素</span></div><div class="line">SearchBox &lt;- remDr$findElement(using=<span class="string">'name'</span>, value=<span class="string">'search_text'</span>)</div><div class="line"><span class="comment"># 传入关键词和回车</span></div><div class="line">SearchBox$sendKeysToElement(list(keyword, key = <span class="string">'enter'</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在网页应该变成了”鹿晗“所出演的电影列表了。</p>
<div align="center"><br><br><img src="3.png" alt="3"><br><br></div>

<hr>
<h3 id="4-读取网页，得到所需元素的文本"><a href="#4-读取网页，得到所需元素的文本" class="headerlink" title="4. 读取网页，得到所需元素的文本"></a>4. 读取网页，得到所需元素的文本</h3><p>首先，我们定位到每一部电影。通过浏览器的“检查”功能，可以看出每部电影的 <code>class=”pl2“</code> 。定位到每部电影之后，提取其中的信息即可。</p>
<ul>
<li><p><code>getElementAttribute</code> ：得到网页信息</p>
<p>接下来就是静态网页的爬虫套路了，使用 <code>rvest</code> 包和 <code>stringr</code> 包里的函数即可。</p>
</li>
<li><p><code>read_html</code> ：读取网页</p>
</li>
<li><p><code>html_nodes</code> ：定位元素</p>
</li>
<li><p><code>html_text</code> ：得到元素文本</p>
</li>
<li><p><code>str_replace_all</code> 、 <code>str_extract</code> ：字符串处理</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 传入网页中所有的电影元素，将提取文本过程写成 MovieDataFunc 函数</span></div><div class="line">MovieDataFunc&lt;-<span class="keyword">function</span>(MovieList)lapply(MovieList,<span class="keyword">function</span>(i)&#123;</div><div class="line">  		<span class="comment"># 读取每部电影的元素</span></div><div class="line"> 		 doc&lt;-i$getElementAttribute(<span class="string">"outerHTML"</span>)[[<span class="number">1</span>]]%&gt;%</div><div class="line">        	read_html()</div><div class="line">        <span class="comment"># 得到电影名 name</span></div><div class="line">        name&lt;-doc%&gt;%</div><div class="line">        	html_nodes(<span class="string">"a"</span>)%&gt;%</div><div class="line">        	html_text()%&gt;%</div><div class="line">        	str_replace_all(pattern=<span class="string">"\\s"</span>,replacement=<span class="string">""</span>)</div><div class="line">        <span class="comment"># 得到评分 rate</span></div><div class="line">        rate&lt;-doc%&gt;%</div><div class="line">        	html_nodes(<span class="string">"span.rating_nums"</span>)%&gt;%</div><div class="line">        	html_text()</div><div class="line">        <span class="comment"># 得到评分人数 pl</span></div><div class="line">        pl&lt;-doc%&gt;%</div><div class="line">        	html_nodes(<span class="string">"span.pl"</span>)%&gt;%</div><div class="line">        	html_text()%&gt;%</div><div class="line">        	str_extract(pattern=<span class="string">"[:digit:]+"</span>)</div><div class="line">        <span class="comment"># 如果缺少评分或评分人数，则设置其为 NA</span></div><div class="line">        rate&lt;-ifelse(identical(rate,character(<span class="number">0</span>)),<span class="literal">NA</span>,rate)</div><div class="line">        pl&lt;-ifelse(identical(pl,character(<span class="number">0</span>)),<span class="literal">NA</span>,pl)</div><div class="line">        <span class="comment"># 返回电影名、评分和评分人数</span></div><div class="line">        <span class="keyword">return</span>(c(name,rate,pl))</div><div class="line">      &#125;</div><div class="line">)</div><div class="line"><span class="comment"># 定位到第一页的所有电影元素</span></div><div class="line">MovieList &lt;- remDr$findElements(<span class="string">'class'</span>,<span class="string">'pl2'</span>)</div><div class="line"><span class="comment"># 得到第一页的电影信息</span></div><div class="line">MovieData&lt;-MovieDataFunc(MovieList)</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-跳转到”下一页“，爬取所有页信息"><a href="#5-跳转到”下一页“，爬取所有页信息" class="headerlink" title="5. 跳转到”下一页“，爬取所有页信息"></a>5. 跳转到”下一页“，爬取所有页信息</h3><p>将第一页的结果爬取完后，我们需要跳转到下一页，实现对所有搜索结果的爬取。</p>
<p>因此，需要判断还有多少页待爬取，遍历剩下的网页即可。</p>
<div align="center"><br><br><img src="4.png" alt="4"><br><br></div>

<p>图中：</p>
<ul>
<li>“第二页”所对应的 <code>xpath</code> 为 <code>//*[@id=&quot;content&quot;]/div/div[1]/div[3]/a</code> ；</li>
<li>”后页“所对应的 <code>class=&quot;next&quot;</code> ，我们使用 <code>css-selectors</code> 定位到它。</li>
</ul>
<ul>
<li><p><code>findElements</code> ：定位所有符合条件的网页元素</p>
</li>
<li><p><code>clickElement</code> ：点击</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 得到剩余网页信息</span></div><div class="line">RemainPage &lt;- remDr$findElements(<span class="string">'xpath'</span>,<span class="string">'//*[@id="content"]/div/div[1]/div[3]/a'</span>)</div><div class="line"><span class="comment"># 爬取剩余网页的电影信息</span></div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:length(RemainPage))&#123;</div><div class="line">    <span class="comment"># 定位到”后页“</span></div><div class="line">    NextPage &lt;- remDr$findElement(<span class="string">'css'</span>, <span class="string">'[class="next"]'</span>)</div><div class="line">    <span class="comment"># 模拟“点击”行为</span></div><div class="line">    NextPage$clickElement()</div><div class="line">    <span class="comment"># 定位到当前网页的所有电影元素</span></div><div class="line">    MovieList &lt;- remDr$findElements(<span class="string">'class'</span>,<span class="string">'pl2'</span>)</div><div class="line">    <span class="comment"># 爬取当前网页的所有电影信息</span></div><div class="line">    MovieData&lt;-c(MovieData,MovieDataFunc(MovieList))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="6-后续工作"><a href="#6-后续工作" class="headerlink" title="6. 后续工作"></a>6. 后续工作</h3><p>当爬取了所有网页的信息之后，我们应当对结果进行整理，并储存。同时，关闭进程，退出浏览器。</p>
<ul>
<li><p><code>quit</code> ：关闭进程，退出浏览器</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将 MovieData 的格式改为数据框，并更改列名</span></div><div class="line">MovieData&lt;-data.frame(t(sapply(MovieData,c)),stringsAsFactors = <span class="literal">F</span>)</div><div class="line">colnames(MovieData)&lt;-c(<span class="string">"MovieName"</span>,<span class="string">"Rate"</span>,<span class="string">"RatePeopleNum"</span>)</div><div class="line"><span class="comment"># 创建 output 文件夹储存爬取结果，并将结果储存至相应的 .csv 文件中</span></div><div class="line"><span class="keyword">if</span>(!file.exists(<span class="string">"output"</span>))dir.create(<span class="string">"output"</span>)</div><div class="line">write.csv(MovieData,paste0(<span class="string">"output/"</span>,keyword,<span class="string">"_moviedata.csv"</span>),row.names = <span class="literal">F</span>)</div><div class="line"><span class="comment"># 关闭进程，退出浏览器</span></div><div class="line">remDr$quit()</div></pre></td></tr></table></figure>
</li>
</ul>
<p>部分爬取结果如下图所示：</p>
<div align="center"><br><br><img src="5.png" alt="5"><br><br></div>

<hr>
<h3 id="7-题外话"><a href="#7-题外话" class="headerlink" title="7. 题外话"></a>7. 题外话</h3><p>我们再做点有意思的工作~ 😜</p>
<p>在 <code>cmd</code> 中运行 <code>Rscipt</code> 命令可以运行 R 的脚本，并传入参数。我们只需要把 <code>keyword&lt;- &quot;鹿晗&quot;</code> 改成 <code>keyword&lt;- commandArgs(T)</code> 。</p>
<ul>
<li><code>commandArgs</code> ：在 <code>Rscript</code> 命令中传入参数</li>
</ul>
<p>[ <del>非必需</del> ] 考虑到本人在 RStudio 中包安装路径并非与 R 默认的包安装路径相同，为了在运行 <code>Rscipt</code> 命令时，顺利载入所需的包，还需要在脚本开头添加所需加载包的位置。</p>
<p>此外，由于在运行 <code>Rscipt</code> 命令时，出现了缺失函数的错误，还需要额外载入 <code>methods</code> 包。</p>
<p>添加下列代码即可：</p>
  <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加所需 R 包位置</span></div><div class="line">.libPaths( unique(c( .libPaths(), <span class="string">"Your own R packages file folder"</span>) ))</div><div class="line"><span class="comment"># 载入额外的 methods 包</span></div><div class="line"><span class="keyword">library</span>(methods)</div><div class="line"><span class="comment"># 设定运行 Rscript 命令时传入参数</span></div><div class="line">keyword&lt;- commandArgs(<span class="literal">T</span>)</div></pre></td></tr></table></figure>
<p>将该 R 脚本文件储存为 <code>Crawler_DoubanMovie.R</code> 。这样一来，你只需在 R 脚本文件所在文件目录下打开命令行工具，输入如下命令，就可以完成整个爬取工作，并得到输出的 <code>.csv</code> 文件了：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Rscript Crawler_DoubanMovie.R 鹿晗</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>你可以在本人的 <a href="https://github.com/VectorF" target="_blank" rel="external">github</a> 上看到这个实例的完整代码。</p>
<p>转载请注明来自 <a href="https://vectorf.github.io">Vector Blog</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 &lt;a href=&quot;https://cran.r-project.org/web/packages/RSelenium/vignettes/RSelenium-basics.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RSelenium&lt;/
    
    </summary>
    
      <category term="R" scheme="https://vectorf.github.io/categories/R/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="RSelenium" scheme="https://vectorf.github.io/tags/RSelenium/"/>
    
      <category term="爬虫" scheme="https://vectorf.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="动态页面" scheme="https://vectorf.github.io/tags/%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2/"/>
    
      <category term="豆瓣电影" scheme="https://vectorf.github.io/tags/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>Python vs R —— 在机器学习和数据分析领域中的对比</title>
    <link href="https://vectorf.github.io/2017/05/04/20170504-PythonvsR%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%86%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>https://vectorf.github.io/2017/05/04/20170504-PythonvsR在机器学习和数据分析领域中的对比/</id>
    <published>2017-05-04T14:00:30.000Z</published>
    <updated>2018-01-31T14:59:40.111Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="封面图.png" width="800" height="400" alt="0"><br><br></div>

<p><em>Image by: Opensource.com</em></p>
<blockquote>
<p>原文链接：<a href="https://opensource.com/article/16/11/python-vs-r-machine-learning-data-analysis" target="_blank" rel="external">Python versus R for machine learning and data analysis</a><br>原文作者： <a href="https://opensource.com/users/tom-radcliffe" target="_blank" rel="external">Tom Radcliffe</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为了鼓励新工具的出现，机器学习和数据分析领域似乎已经成了“开源”的天下。Python 和 R 语言都具有健全的生态系统，其中包括了很多开源工具和资源库，从而能够帮助任何水平层级的数据科学家展示其分析工作。</p>
<p>机器学习和数据分析之间的差异有些难以言明，但二者最主要的不同就在于，比起模型的可解释性，机器学习更加强调预测的准确性；而数据分析则更加看重模型的可解释性以及统计推断。Python ，由于更看重预测结果的准确性，使其成为机器学习的一把利器。 R ，作为一种以统计推断为导向的编程语言，在数据分析界也得到广泛应用。</p>
<p>当然，这并不代表二者只能在各自的一个领域中得到应用。Python 也可以高效地完成数据分析工作，R 在机器学习中也具有一定的灵活性。它们都拥有相当多的资源库去实现彼此特定的函数功能，比如 Python 就有很多资源库来提高自己统计推断的能力，R 也有很多包可以提升预测的准确率。</p>
<h2 id="Python-中关于机器学习和数据分析的包"><a href="#Python-中关于机器学习和数据分析的包" class="headerlink" title="Python 中关于机器学习和数据分析的包"></a>Python 中关于机器学习和数据分析的包</h2><p>虽然 Python 本身就更倾向于机器学习， 但它还是有很多包可以进一步优化这一属性。PyBrain 是一个模块化的机器学习资源库，其中包含很多有效的算法可以满足机器学习任务的需要。除了很多直观灵活的算法，这个资源库还内置很多环境可以用来检验和比较这些机器学习算法的效果。</p>
<p>Scikit-learn 可能是 Python 最受欢迎的机器学习资源库了。基于 Numpy 和 Scipy ，scikit-learn 提供大量用于数据挖掘和分析的工具，从而提高了 Python 本就出色的机器学习可用性。NumPy 和 SciPy 各自为战，虽然它们是 Python 中数据分析的核心部分，但数据分析家更可能仅仅原生地去使用它们，而不是基于一个更高的角度。 Scikit-learn 却将二者结合成为一个机器学习资源库，同时也降低了大家的学习门槛。</p>
<p>在数据分析领域，Python 也因几个库而包受推崇。 作为其中最为著名的库之一，Pandas 为 Python 提供了高性能处理的数据结构和数据分析工具。如同其他很多 Python 的库一样，从你着手一个新项目到真正做些有价值的工作这过程的时间将会因它大大缩短。如果你执着于 Python 同时又希望使用 R 的功能， RPy2 库能够提供所有 R 的主要功能，并给你一个 R 在 Python 中使用的流畅化体验。</p>
<h2 id="R-中关于机器学习和数据分析的包"><a href="#R-中关于机器学习和数据分析的包" class="headerlink" title="R 中关于机器学习和数据分析的包"></a>R 中关于机器学习和数据分析的包</h2><p>就像 Python 一样，R 也拥有大量的包来提升它的表现。要想在机器学习领域媲美 Python，R 中的 Nnet 包具有快速构建神经网络模型的能力。通过提供一系列函数来提升所构建模型的有效性，Caret 包也可以加强 R 在机器学习的能力。</p>
<p>就 R 在数据分析领域的表现，仍然有很多包可以用来提升它本就出色的能力。不管是建模前的准备，建模，以及建模后的分析工作，R 都有很多包可以胜任。这些包大多专门用来完成特定的任务，比如数据的可视化，连续变量回归和模型验证。</p>
<p>两种编程语言都拥有如此多交叉功能的资源库和包，你会选择哪种编程语言作为伴你在数据战场厮杀的武器呢？</p>
<h2 id="在机器学习和数据分析中的-Python"><a href="#在机器学习和数据分析中的-Python" class="headerlink" title="在机器学习和数据分析中的 Python"></a>在机器学习和数据分析中的 Python</h2><p>如果你已经有一些编程的基础了，Python 可能更加适合你。相较于 R ，Python 的语法结构与其他编程语言更加类似，便于上手。此外，就像是口头语一样， Python 代码的可读性也是无人能及的。这种代码的可读性更加强调提高生产力，而 R 非标准的代码可能会导致在编程进程中的磕绊。</p>
<p>Python 是一种很灵活的编程语言，所以如果你打算把已经完成的机器学习或者数据分析的项目移植到其他领域，那么使用 Python 可以使你不必再去学习新的编程语言。</p>
<p>Python 的灵活性也使得它非常适用于生产。举个例子，当数据分析的任务需要与 Web 应用程序相整合的时候，你仍然可以使用 Python 且不需要和其他编程语言相整合。而虽然 R 是一个很好的数据分析的工具，但它在数据分析之外的领域却有所限制。</p>
<p>如果你刚入门编程，对那些“标准化”的语法并不熟悉，那么无论哪种编程语言的学习曲线对你而言都差不多。但要是你希望跨过机器学习和数据分析的门槛，Python 可能是更好的选择。特别是 Python 有 scikit-learn 库的加持。这个库表现良好且更新频繁。 R 可能有很多包，但显得有些零乱且一致性较差。</p>
<h2 id="在机器学习和数据分析中的-R"><a href="#在机器学习和数据分析中的-R" class="headerlink" title="在机器学习和数据分析中的 R"></a>在机器学习和数据分析中的 R</h2><p>目前， R 主要是用在科研和调查工作中。然而，随着 R 逐渐扩展到商业领域，这一现状也开始得到改变。 R 是由统计学家所创造出来的，因此它可以很轻易地管理基本的数据结构。给数据打标签，填充缺失值，筛选等等这些对于 R 而言很容易就可以实现，R 也更加强调易于操作的数据分析，统计和图形化模型工作。</p>
<p>由于 R 是作为统计性的编程语言而构建的，因此它具有很好的统计方面的支持。它能够很好地展现统计学家的思维，所以如果你具有统计背景的话，用起来会很顺手。诸如像 statsmodels 包能够基本覆盖 Python 中的统计模型，而且 R 中与统计模型相关的包功能会更加强大。对于刚入门的程序员， R 只需要写几行代码就能够构建模型了，这样一来，它会比 Python 更容易解释一些。</p>
<p>R 中与 Python 的 pandas 库功能最为接近的大概就是 dplyr 包了，只不过它会比 pandas 库限制得更多。虽然这听起来不太好，但实际上使用 dplyr 包时会促使你更专注于寻求问题的解决之道，而且 dplyr 包的代码也比 pandas 库更容易理解。</p>
<h2 id="选择你自己的编程语言吧"><a href="#选择你自己的编程语言吧" class="headerlink" title="选择你自己的编程语言吧"></a>选择你自己的编程语言吧</h2><p>R 最大的问题在于一致性不够好。其中的算法流程被分成三块，使得它们相对而言不够统一。你不得不学习新的方法来建模并用新的算法来做预测，伴随这个过程，结果的有效性将会明显下降。你需要理解每个包是怎么用的，同样地，R 中包的帮助文档由于不够完整，一致性也不好。</p>
<p>不过，要是你需要一个数据分析的工具用于学术， R 绝对可以胜任这项工作。 Python 则被广泛地用于商业也更便于协作，不过 R 也越来越得到重视了。不管是日常的使用和机器学习，还是通过和 R 一般众多的包来做数据分析， Python 都能做到，因此也更推荐使用 Python 。</p>
<p>如果你对 R 还比较陌生，不如学习 Python 并通过 RPy2 包来实现 R 的功能。 这样一来，你就可以在一种编程语言里同时使用二者的功能，而且由于很多公司已经开发了在 Python 中使用的生产系统， Python 可谓生产力高效。这点在 R 中就不适用了。一旦你学会了 RPy2 ，再想跳到 R 里面并没有那么复杂，不过反过来就相对而言困难得多了。</p>
<p>不管你想解决什么类型的问题， Python 和 R 都有功能相近的资源库可以使用。每种编程语言都有很多的分支、模块、集成开发环境和算法，以至于你难以出什么大的纰漏。不过要是你希望使用一个灵活性强，扩展性好，多功能又能胜任机器学习和数据分析工作的编程语言， Python 或许是明智之选。</p>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;封面图.png&quot; width=&quot;800&quot; height=&quot;400&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Image by: Opensource.com&lt;/em&gt;&lt;/p&gt;
&lt;bl
    
    </summary>
    
      <category term="数据科学" scheme="https://vectorf.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（七）——非日数据</title>
    <link href="https://vectorf.github.io/2017/03/14/20170314-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/14/20170314-Prophet之使用篇（七）/</id>
    <published>2017-03-14T13:21:11.000Z</published>
    <updated>2018-01-31T14:54:05.543Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/non-daily_data.html" target="_blank" rel="external">Prophet 的官方说明文档之 “非日数据”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<p>Prophet 处理的对象并非必须是日数据，不过要是试图通过非日数据来预测每日的情况或拟合季节性效应，往往会得到奇奇怪怪的结果。下面使用美国零售业销售量数据来预测未来 10 年的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">df = pd.read_csv(<span class="string">'./examples/example_retail_sales.csv'</span>)</div><div class="line">m = Prophet().fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">3652</span>)</div><div class="line">fcst = m.predict(future)</div><div class="line">m.plot(fcst);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">df &lt;- read.csv(<span class="string">'./examples/example_retail_sales.csv'</span>)</div><div class="line">m &lt;- prophet(df)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">3652</span>)</div><div class="line">fcst &lt;- predict(m, future)</div><div class="line">plot(m, fcst);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet7_1.png" alt="1"><br><br></div>

<p>预测结果看起来非常杂乱，原因正是在于这个特殊的数据集使用的是月数据。当我们拟合年度效应时，只有每个月第一天的数据，而且对于其他天的周期效应是不可测且过拟合的。当你使用 Prophet 拟合月度数据时，可以通过在 <code>make_future_dataframe</code> 中传入频率参数只做月度的预测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">future = m.make_future_dataframe(periods=<span class="number">120</span>, freq=<span class="string">'M'</span>)</div><div class="line">fcst = m.predict(future)</div><div class="line">m.plot(fcst);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">120</span>, freq = <span class="string">'m'</span>)</div><div class="line">fcst &lt;- predict(m, future)</div><div class="line">plot(m, fcst)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet7_2.png" alt="2"><br><br></div>

<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=&quot;
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（六）——异常值</title>
    <link href="https://vectorf.github.io/2017/03/14/20170314-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/14/20170314-Prophet之使用篇（六）/</id>
    <published>2017-03-14T13:21:04.000Z</published>
    <updated>2018-01-31T14:54:08.030Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/outliers.html" target="_blank" rel="external">Prophet 的官方说明文档之 “异常值”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<p>异常值主要通过两种方式影响 Prophet 预测结果。下面我们使用之前使用过的 R 语言维基百科主页对数访问量的数据来建模预测，只不过使用存在时间间隔并不完整的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">df = pd.read_csv(<span class="string">'./examples/example_wp_R_outliers1.csv'</span>)</div><div class="line">df[<span class="string">'y'</span>] = np.log(df[<span class="string">'y'</span>])</div><div class="line">m = Prophet()</div><div class="line">m.fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">1096</span>)</div><div class="line">forecast = m.predict(future)</div><div class="line">m.plot(forecast);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">df &lt;- read.csv(<span class="string">'./examples/example_wp_R_outliers1.csv'</span>)</div><div class="line">df$y &lt;- log(df$y)</div><div class="line">m &lt;- prophet(df)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">1096</span>)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet6_1.png" alt="1"><br><br></div>

<p>如上 R 输出图所示，趋势预测看似合理，预测区间的估计却过于广泛。 Prophet 虽能够处理历史数据中的异常值，但仅仅是将它们与趋势的变化拟合在一起，认为未来也会有类似的趋势变化。</p>
<p>处理异常值最好的方法是移除它们，而 Prophet 使能够处理缺失数据的。如果在历史数据中某行的值为空（ <code>NA</code> ），但是在待预测日期数据框 <code>future</code> 中仍保留这个日期，那么 Prophet 依旧可以给出该行的预测值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">df.loc[(df[<span class="string">'ds'</span>] &gt; <span class="string">'2010-01-01'</span>) &amp; (df[<span class="string">'ds'</span>] &lt; <span class="string">'2011-01-01'</span>), <span class="string">'y'</span>] = <span class="keyword">None</span></div><div class="line">model = Prophet().fit(df)</div><div class="line">model.plot(model.predict(future));</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">outliers &lt;- (as.Date(df$ds) &gt; as.Date(<span class="string">'2010-01-01'</span>)</div><div class="line">             &amp; as.Date(df$ds) &lt; as.Date(<span class="string">'2011-01-01'</span>))</div><div class="line">df$y[outliers] = <span class="literal">NA</span></div><div class="line">m &lt;- prophet(df)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet6_2.png" alt="2"><br><br></div>

<p>上述这个实例虽然影响了不确定性的估计，却没有影响到主要的预测值 <code>yhat</code> 。但是，现实往往并非如此，接下来，在上述数据集基础上加入新的异常值后再建模预测：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">df = pd.read_csv(<span class="string">'./examples/example_wp_R_outliers2.csv'</span>)</div><div class="line">df[<span class="string">'y'</span>] = np.log(df[<span class="string">'y'</span>])</div><div class="line">m = Prophet()</div><div class="line">m.fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">1096</span>)</div><div class="line">forecast = m.predict(future)</div><div class="line">m.plot(forecast);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">df &lt;- read.csv(<span class="string">'./examples/example_wp_R_outliers2.csv'</span>)</div><div class="line">df$y = log(df$y)</div><div class="line">m &lt;- prophet(df)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">1096</span>)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet6_3.png" alt="3"><br><br></div>

<p>这里 2015年 6 月存在一些异常值破坏了季节效应的估计，因此未来的预测也会永久地受到这个影响。最好的解决方法就是移除这些异常值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">df.loc[(df[<span class="string">'ds'</span>] &gt; <span class="string">'2015-06-01'</span>) &amp; (df[<span class="string">'ds'</span>] &lt; <span class="string">'2015-06-30'</span>), <span class="string">'y'</span>] = <span class="keyword">None</span></div><div class="line">m = Prophet().fit(df)</div><div class="line">m.plot(m.predict(future));</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">outliers &lt;- (as.Date(df$ds) &gt; as.Date(<span class="string">'2015-06-01'</span>)</div><div class="line">             &amp; as.Date(df$ds) &lt; as.Date(<span class="string">'2015-06-30'</span>))</div><div class="line">df$y[outliers] = <span class="literal">NA</span></div><div class="line">m &lt;- prophet(df)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet6_4.png" alt="4"><br><br></div>

<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=&quot;
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（五）——预测区间</title>
    <link href="https://vectorf.github.io/2017/03/14/20170314-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/14/20170314-Prophet之使用篇（五）/</id>
    <published>2017-03-14T13:20:58.000Z</published>
    <updated>2018-01-31T14:53:54.272Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/uncertainty_intervals.html" target="_blank" rel="external">Prophet 的官方说明文档之 “预测区间”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<p>默认情况下， Prophet 的返回结果中会包括预测值 <code>yhat</code> 的预测区间。当然，预测区间的估计需建立在一些重要的假设前提下。</p>
<p>在预测时，不确定性主要来源于三个部分：趋势中的不确定性、季节效应估计中的不确定性和观测值的噪声影响。</p>
<h2 id="趋势中的不确定性"><a href="#趋势中的不确定性" class="headerlink" title="趋势中的不确定性"></a>趋势中的不确定性</h2><p>预测中，不确定性最大的来源就在于未来趋势改变的不确定性。在之前教程中的时间序列实例中，我们可以发现历史数据具有明显的趋势性。 Prophet 能够监测并去拟合它，但是我们期望得到的趋势改变究竟会如何走向呢？或许这是无解的，因此我们尽可能地做出最合理的推断，假定 “未来将会和历史具有相似的趋势” 。尤其重要的是，我们假定未来趋势的平均变动频率和幅度和我们观测到的历史值是一样的，从而预测趋势的变化并通过计算，最终得到预测区间。</p>
<p>这种衡量不确定性的方法具有以下性质：变化速率灵活性更大时（通过增大参数 <code>changepoint_prior_scale</code> 的值），预测的不确定性也会随之增大。原因在于如果将历史数据中更多的变化速率加入了模型，也就代表我们认为未来也会变化得更多，就会使得预测区间成为反映过拟合的标志。</p>
<p>预测区间的宽度（默认下，是 80% ）可以通过设置 <code>interval_width</code> 参数来控制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(interval_width=<span class="number">0.95</span>).fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, interval.width = <span class="number">0.95</span>)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div></pre></td></tr></table></figure>
<p>由于预测区间估计时假定未来将会和过去保持一样的变化频率和幅度，而这个假定可能并不正确，所以预测区间的估计不可能完全准确。</p>
<h2 id="季节效应中的不确定性"><a href="#季节效应中的不确定性" class="headerlink" title="季节效应中的不确定性"></a>季节效应中的不确定性</h2><p>默认情况下， Prophet 只会返回趋势中的不确定性和观测值噪声的影响。你必须使用贝叶斯取样的方法来得到季节效应的不确定性，可通过设置 <code>mcmc.samples</code> 参数（默认下取 0 ）来实现。下面使用 <a href="https://vectorf.github.io/2017/03/12/20170312-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/">Prophet 之使用篇（一）</a> 中佩顿 · 曼宁的数据为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(mcmc_samples=<span class="number">500</span>).fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, mcmc.samples = <span class="number">500</span>)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div></pre></td></tr></table></figure>
<p>上述代码将最大后验估计（ MAP ）取代为马尔科夫蒙特卡洛取样 （ MCMC ），并且将计算时间从 10 秒延长到 10 分钟。如果做了全取样，就能通过绘图看到季节效应的不确定性了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m.plot_components(forecast);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">prophet_plot_components(m, forecast);</div></pre></td></tr></table></figure>
<div align="centet"><br><br><img src="Prophet5_1.png" alt="1"><br><br></div>

<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=&quot;
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（四）——节假日效应</title>
    <link href="https://vectorf.github.io/2017/03/14/20170314-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/14/20170314-Prophet之使用篇（四）/</id>
    <published>2017-03-14T13:20:51.000Z</published>
    <updated>2018-01-31T14:54:01.371Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/holiday_effects.html" target="_blank" rel="external">Prophet 的官方说明文档之 “节假日效应”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<h2 id="对节假日建模"><a href="#对节假日建模" class="headerlink" title="对节假日建模"></a>对节假日建模</h2><p>如果需要专门对节假日进行建模，你就必须得为此创建一个新的数据框，其中包含两列（节假日 <code>holiday</code> 和日期戳 <code>ds</code> ），每行分别记录了每个出现的节假日。这个数据框必须包含所有出现的节假日，不仅是历史数据集中还是待预测的时期中的。如果这些节假日并没有在待预测的时期中被注明， Prophet 也会利用历史数据对它们建模，但预测未来时却不会使用这些模型来预测。</p>
<p>你可以在这个数据框基础上再新建两列 <code>lower_window</code> 和 <code>upper_window</code> ，从而将节假日的时间扩展成一个区间 [ <code>lower_window</code> , <code>upper_window</code> ] 。举例来说，如果想将平安夜也加入到 “圣诞节” 里，就设置 <code>lower_window = -1 , upper_window = 0</code> ;如果想将黑色星期五加入到 “感恩节” 里，就设置 <code>lower_window = 0 , upper_window = 1</code> 。</p>
<p>下面我们创建一个数据框，其中包含了所有佩顿 · 曼宁参加过的决赛日期：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">playoffs = pd.DataFrame(&#123;</div><div class="line">  <span class="string">'holiday'</span>: <span class="string">'playoff'</span>,</div><div class="line">  <span class="string">'ds'</span>: pd.to_datetime([<span class="string">'2008-01-13'</span>, <span class="string">'2009-01-03'</span>, <span class="string">'2010-01-16'</span>,</div><div class="line">                        <span class="string">'2010-01-24'</span>, <span class="string">'2010-02-07'</span>, <span class="string">'2011-01-08'</span>,</div><div class="line">                        <span class="string">'2013-01-12'</span>, <span class="string">'2014-01-12'</span>, <span class="string">'2014-01-19'</span>,</div><div class="line">                        <span class="string">'2014-02-02'</span>, <span class="string">'2015-01-11'</span>, <span class="string">'2016-01-17'</span>,</div><div class="line">                        <span class="string">'2016-01-24'</span>, <span class="string">'2016-02-07'</span>]),</div><div class="line">  <span class="string">'lower_window'</span>: <span class="number">0</span>,</div><div class="line">  <span class="string">'upper_window'</span>: <span class="number">1</span>,</div><div class="line">&#125;)</div><div class="line">superbowls = pd.DataFrame(&#123;</div><div class="line">  <span class="string">'holiday'</span>: <span class="string">'superbowl'</span>,</div><div class="line">  <span class="string">'ds'</span>: pd.to_datetime([<span class="string">'2010-02-07'</span>, <span class="string">'2014-02-02'</span>, <span class="string">'2016-02-07'</span>]),</div><div class="line">  <span class="string">'lower_window'</span>: <span class="number">0</span>,</div><div class="line">  <span class="string">'upper_window'</span>: <span class="number">1</span>,</div><div class="line">&#125;)</div><div class="line">holidays = pd.concat((playoffs, superbowls))</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">playoffs &lt;- data_frame(</div><div class="line">  holiday = <span class="string">'playoff'</span>,</div><div class="line">  ds = as.Date(c(<span class="string">'2008-01-13'</span>, <span class="string">'2009-01-03'</span>, <span class="string">'2010-01-16'</span>,</div><div class="line">                 <span class="string">'2010-01-24'</span>, <span class="string">'2010-02-07'</span>, <span class="string">'2011-01-08'</span>,</div><div class="line">                 <span class="string">'2013-01-12'</span>, <span class="string">'2014-01-12'</span>, <span class="string">'2014-01-19'</span>,</div><div class="line">                 <span class="string">'2014-02-02'</span>, <span class="string">'2015-01-11'</span>, <span class="string">'2016-01-17'</span>,</div><div class="line">                 <span class="string">'2016-01-24'</span>, <span class="string">'2016-02-07'</span>)),</div><div class="line">  lower_window = <span class="number">0</span>,</div><div class="line">  upper_window = <span class="number">1</span></div><div class="line">)</div><div class="line">superbowls &lt;- data_frame(</div><div class="line">  holiday = <span class="string">'superbowl'</span>,</div><div class="line">  ds = as.Date(c(<span class="string">'2010-02-07'</span>, <span class="string">'2014-02-02'</span>, <span class="string">'2016-02-07'</span>)),</div><div class="line">  lower_window = <span class="number">0</span>,</div><div class="line">  upper_window = <span class="number">1</span></div><div class="line">)</div><div class="line">holidays &lt;- bind_rows(playoffs, superbowls)</div></pre></td></tr></table></figure>
<p>上述代码中，我们将超级碗的日期既记录在了决赛的日期数据框中，也记录在了超级碗的日期数据框中。这就会造成超级碗日期的效应会在决赛日期的作用下叠加两次。</p>
<p>一旦这个数据框创建好了，就可以通过传入 <code>holidays</code> 参数使得在预测时考虑上节假日效应。这里我们仍以 <a href="https://vectorf.github.io/2017/03/12/20170312-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/">Prophet 之使用篇（一）</a> 中佩顿 · 曼宁的数据为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(holidays=holidays)</div><div class="line">m.fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, holidays = holidays)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div></pre></td></tr></table></figure>
<p>可通过 <code>forecast</code> 数据框，来展示节假日效应：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">forecast[(forecast[<span class="string">'playoff'</span>] + forecast[<span class="string">'superbowl'</span>]).abs() &gt; <span class="number">0</span>][</div><div class="line">        [<span class="string">'ds'</span>, <span class="string">'playoff'</span>, <span class="string">'superbowl'</span>]][<span class="number">-10</span>:]</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">forecast %&gt;% </div><div class="line">  select(ds, playoff, superbowl) %&gt;% </div><div class="line">  filter(abs(playoff + superbowl) &gt; <span class="number">0</span>) %&gt;%</div><div class="line">  tail(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>R 代码输出如下所示：</p>
<div align="center"><br><br><img src="Prophet4_1.png" alt="1"><br><br></div>

<p>在成分分析的图中，如下所示，也可以看到节假日效应。我们可以发现，在决赛日期附近有一个穿透，而在超级碗日期时穿透则更为明显。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m.plot_components(forecast);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">prophet_plot_components(m, forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet4_2.png" alt="2"><br><br></div>

<h2 id="对节假日和季节性设定先验规模"><a href="#对节假日和季节性设定先验规模" class="headerlink" title="对节假日和季节性设定先验规模"></a>对节假日和季节性设定先验规模</h2><p>如果发现节假日效应被过度拟合了，通过设置参数 <code>holidays_prior_scale</code> 可以调整它们的先验规模来使之平滑，默认下该值取 10 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(holidays=holidays, holidays_prior_scale=<span class="number">1</span>).fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div><div class="line">forecast[(forecast[<span class="string">'playoff'</span>] + forecast[<span class="string">'superbowl'</span>]).abs() &gt; <span class="number">0</span>][</div><div class="line">    [<span class="string">'ds'</span>, <span class="string">'playoff'</span>, <span class="string">'superbowl'</span>]][<span class="number">-10</span>:]</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, holidays = holidays, holidays.prior.scale = <span class="number">1</span>)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">forecast %&gt;% </div><div class="line">  select(ds, playoff, superbowl) %&gt;% </div><div class="line">  filter(abs(playoff + superbowl) &gt; <span class="number">0</span>) %&gt;%</div><div class="line">  tail(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>R 代码输出结果如下所示：</p>
<div align="center"><br><br><img src="Prophet4_3.png" alt="3"><br><br></div>

<p>和之前相比，节假日效应的规模被减弱了，特别是对观测值较少的超级碗而言。类似的，还有一个 <code>seasonality_prior_scale</code> 参数可以用来调整模型对于季节性的拟合程度。</p>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=&quot;
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（三）——趋势突变点</title>
    <link href="https://vectorf.github.io/2017/03/14/20170314-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/14/20170314-Prophet之使用篇（三）/</id>
    <published>2017-03-14T13:20:43.000Z</published>
    <updated>2018-01-31T14:53:57.400Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/trend_changepoints.html" target="_blank" rel="external">Prophet 的官方说明文档之 “趋势突变点”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<p>在之前的教程案例中，我们可以发现真实的时间序列数据往往在趋势中存在一些突变点。默认情况下， Prophet 将自动监测到这些点，并对趋势做适当地调整。不过，要是对趋势建模时发生了一些问题，例如：Prophet 不小心忽略了一个趋势速率的变化或者对历史数据趋势变化存在过拟合现象，希望对趋势的调整过程做更好地控制的话，那么下面将会介绍几种可以使用的方法。</p>
<h2 id="Prophet-中的自动监测突变点"><a href="#Prophet-中的自动监测突变点" class="headerlink" title="Prophet 中的自动监测突变点"></a>Prophet 中的自动监测突变点</h2><p>Prophet 首先是通过在大量潜在的突变点（变化速率突变）中进行识别来监测突变点的。之后对趋势变化的幅度做稀疏先验（等同于 L1 正则化）——实际上 Prophet 在建模时会存在很多变化速率突变的点，但只会尽可能少地使用它们。以 <a href="https://vectorf.github.io/2017/03/12/20170312-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/">Prophet 之使用篇（一）</a> 中佩顿 · 曼宁的数据为例，默认下， Prophet 会识别出 25 个潜在的突变点（均匀分布在在前 80% 的时间序列数据中）。下图中的竖线指出这些潜在的突变点所在的位置。</p>
<div align="center"><br><br><img src="Prophet3_1.png" alt="1"><br><br></div>

<p>虽然存在很多变化速率可能会突变的点，但由于做了稀疏先验，绝大多数突变点并不会包含在建模过程中。如下图示，通过观察对每个突变点绘制的速率变化值图，可以发现这一点。</p>
<div align="center"><br><br><img src="Prophet3_2.png" alt="2"><br><br></div>

<p>潜在突变点的数量可以通过设置 <code>n_changepoints</code> 参数来指定，但最好还是利用调整正则化过程来修正。</p>
<h2 id="调整趋势的灵活性"><a href="#调整趋势的灵活性" class="headerlink" title="调整趋势的灵活性"></a>调整趋势的灵活性</h2><p>如果趋势的变化被过度拟合（即过于灵活）或者拟合不足（即灵活性不够），可以利用输入参数 <code>changepoint_prior_scale</code> 来调整稀疏先验的程度。默认下，这个参数被指定为 0.05 。</p>
<p>增加这个值，会导致趋势拟合得更加灵活。如下代码和图所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, changepoint.prior.scale = <span class="number">0.5</span>)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(changepoint_prior_scale=<span class="number">0.5</span>)</div><div class="line">m.fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div><div class="line">m.plot(forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet3_3.png" alt="3"><br><br></div>

<p>减少这个值，会导致趋势拟合得灵活性降低。如下代码和图所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, changepoint.prior.scale = <span class="number">0.001</span>)</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(changepoint_prior_scale=<span class="number">0.001</span>)</div><div class="line">m.fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div><div class="line">m.plot(forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet3_4.png" alt="4"><br><br></div>



<h2 id="指定突变点的位置"><a href="#指定突变点的位置" class="headerlink" title="指定突变点的位置"></a>指定突变点的位置</h2><p>如果你希望手动指定潜在突变点的位置而不是利用自动的突变点监测，可以使用 <code>changepoints</code> 参数。</p>
<p>代码和图如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, changepoints = c(as.Date(<span class="string">'2014-01-01'</span>)))</div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">plot(m, forecast);</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(changepoints=[<span class="string">'2014-01-01'</span>])</div><div class="line">m.fit(df)</div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">forecast = m.predict(future)</div><div class="line">m.plot(forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet3_5.png" alt="5"><br><br></div>

<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=&quot;
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（二）——预测增长</title>
    <link href="https://vectorf.github.io/2017/03/14/20170314-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/14/20170314-Prophet之使用篇（二）/</id>
    <published>2017-03-14T13:18:12.000Z</published>
    <updated>2018-01-31T14:53:38.080Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>


<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/forecasting_growth.html" target="_blank" rel="external">Prophet 的官方说明文档之 “预测增长”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<p>默认情况下， Prophet 使用线性模型进行预测。当预测增长情况时，通常会存在可到达的最大极限值，例如：总市场规模、总人口数等等。这被称做承载能力，那么预测时就应当在接近该值时趋于饱和。</p>
<p>Prophet 可使用 <a href="https://en.wikipedia.org/wiki/Logistic_function" target="_blank" rel="external">logistic 增长</a> 趋势模型进行预测，同时指定承载能力。下面使用 <a href="https://en.wikipedia.org/wiki/R_%28programming_language%29" target="_blank" rel="external">R 语言的维基百科主页</a> 访问量（取对数）的实例来进行说明。</p>
<p>首先，读入数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> fbprophet <span class="keyword">import</span> Prophet</div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">'./examples/example_wp_R.csv'</span>)</div><div class="line">df[<span class="string">'y'</span>] = np.log(df[<span class="string">'y'</span>])</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line"><span class="keyword">library</span>(prophet)</div><div class="line"></div><div class="line">df &lt;- read.csv(<span class="string">'./examples/example_wp_R.csv'</span>)</div><div class="line">df$y &lt;- log(df$y)</div></pre></td></tr></table></figure>
<p>新建一列 <code>cap</code> 来指定承载能力的大小。本实例中假设取某个特定的值，通常情况下这个值应当通过市场规模的数据或专业知识来决定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">df[<span class="string">'cap'</span>] = <span class="number">8.5</span></div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">df$cap &lt;- <span class="number">8.5</span></div></pre></td></tr></table></figure>
<p>值得注意的是数据框的每行都必须指定 <code>cap</code> 的值，但并非需要是恒定值。如果市场规模在不断地增长，那么 <code>cap</code> 也可以是不断增长的序列。</p>
<p>如之前教程所述来拟合模型，并且通过一个新增的参数来指定采用 logistic 增长：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">m = Prophet(growth=<span class="string">'logistic'</span>)</div><div class="line">m.fit(df)</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">m &lt;- prophet(df, growth = <span class="string">'logistic'</span>)</div></pre></td></tr></table></figure>
<p>如前所述，我们可以创建一个数据框来预测未来值，不过这里要指定未来的承载能力。我们将未来的承载能力设定得和历史数据一样，并且预测未来 3 年的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">future = m.make_future_dataframe(periods=<span class="number">1826</span>)</div><div class="line">future[<span class="string">'cap'</span>] = <span class="number">8.5</span></div><div class="line">fcst = m.predict(future)</div><div class="line">m.plot(fcst);</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R</span></div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">1826</span>)</div><div class="line">future$cap &lt;- <span class="number">8.5</span></div><div class="line">fcst &lt;- predict(m, future)</div><div class="line">plot(m, fcst)</div></pre></td></tr></table></figure>
<p>R 中预测结果如下图所示：</p>
<div align="center"><br><br><img src="Prophet2_1.png" alt="1"><br><br></div>

<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a> </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之使用篇（一）——简易入门</title>
    <link href="https://vectorf.github.io/2017/03/12/20170312-Prophet%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/03/12/20170312-Prophet之使用篇（一）/</id>
    <published>2017-03-12T06:02:12.000Z</published>
    <updated>2018-01-31T14:53:44.568Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本使用说明教程主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/quick_start.html" target="_blank" rel="external">Prophet 的官方说明文档之 “简易入门”</a></p>
<p>教程中使用的数据集可在 <a href="https://github.com/facebookincubator/prophet" target="_blank" rel="external">Prophet 的 github 主页</a> 中的 <a href="https://github.com/facebookincubator/prophet/tree/master/examples" target="_blank" rel="external">examples 文件夹</a> 内下载得到。</p>
</blockquote>
<h2 id="Python-中的应用程序接口"><a href="#Python-中的应用程序接口" class="headerlink" title="Python 中的应用程序接口"></a>Python 中的应用程序接口</h2><p>Prophet 遵循 <code>sklearn</code> 库建模的应用程序接口。我们创建了一个 Prophet 类的实例，其中使用了“拟合模型” <code>fit</code> 和“预测” <code>predict</code> 方法。</p>
<p>Prophet 的输入量往往是一个包含两列的数据框：<code>ds</code> 和 <code>y</code> 。<code>ds</code> 列（即日期戳）必须包含日期或者是具体的时间点。 <code>y</code> 列必须是数值变量，表示我们希望去预测的量。</p>
<p>下面实例中使用的是 <a href="https://en.wikipedia.org/wiki/Peyton_Manning" target="_blank" rel="external">佩顿 · 曼宁的维基百科主页</a> 每日访问量的时间序列数据（2007/12/10 - 2016/01/20）。我们使用 R 中的 <a href="https://cran.r-project.org/web/packages/wikipediatrend/vignettes/using-wikipediatrend.html" target="_blank" rel="external">Wikipediatrend</a> 包获取该数据集。这个数据集具有多季节周期性、不断变化的增长率和可以拟合特定日期（例如佩顿 · 曼宁的决赛和超级碗）的情况等 Prophet 适用的性质，因此可以作为一个不错的例子。（<em>注：</em>佩顿 · 曼宁为前美式橄榄球四分卫）</p>
<p>首先，我们导入数据，并且对 y 变量取对数变换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在 Python 中载入所需库</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> fbprophet <span class="keyword">import</span> Prophet</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 读入数据集，并对日访问量 y 取对数处理</span></div><div class="line">df = pd.read_csv(<span class="string">'./examples/example_wp_peyton_manning.csv'</span>)</div><div class="line">df[<span class="string">'y'</span>] = np.log(df[<span class="string">'y'</span>])</div><div class="line">df.head()</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_1.png" alt="1_1"><br><br></div>

<p>通过对一个 Prophet 对象进行实例化来拟合模型，任何影响预测过程的设置都将在构造模型时被指定。接下来，就可以使用 <code>fit</code> 方法代入历史数据集来拟合模型，拟合过程应当花费 1 - 5 秒。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 拟合模型</span></div><div class="line">m = Prophet()</div><div class="line">m.fit(df);</div></pre></td></tr></table></figure>
<p>预测过程则需要建立在包含日期 <code>ds</code> 列的数据框基础上。通过使用辅助的方法 <code>Prophet.make_future_dataframe</code> 来将未来的日期扩展指定的天数，得到一个合规的数据框。默认情况下，这样做会自动包含历史数据的日期，因此我们也可以用来查看模型对于历史数据的拟合效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建待预测日期数据框，periods = 365 代表除历史数据的日期外再往后推 365 天</span></div><div class="line">future = m.make_future_dataframe(periods=<span class="number">365</span>)</div><div class="line">future.tail()</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_2.png" alt="1_2"><br><br></div>

<p><code>predict</code> 方法将会对每一行未来 <code>future</code> 日期得到一个预测值（称为 <code>yhat</code> ）。如果你传入了历史数据的日期，它将会提供样本的模型拟合值。预测 <code>forecast</code> 创建的对象应当是一个新的数据框，其中包含一列预测值 <code>yhat</code> ，以及成分的分析和置信区间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测数据集</span></div><div class="line">forecast = m.predict(future)</div><div class="line">forecast[[<span class="string">'ds'</span>, <span class="string">'yhat'</span>, <span class="string">'yhat_lower'</span>, <span class="string">'yhat_upper'</span>]].tail()</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_3.png" alt="1_3"><br><br></div>

<p>通过 <code>Prophet.plot</code> 方法传入预测得到的数据框，可以对预测的效果进行绘图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示预测结果</span></div><div class="line">m.plot(forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_4.png" alt="1-4"><br><br></div>

<p>如果想查看预测的成分分析，可以使用 <code>Prophet.plot_components</code> 方法。默认情况下，将展示趋势、年度效应和时间序列的周效应。如果之前包含了节假日，也会展示出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测的成分分析绘图，展示预测中的趋势、周效应和年度效应</span></div><div class="line">m.plot_components(forecast);</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_5.png" alt="1-5"><br><br></div>

<h2 id="R-中的应用程序接口"><a href="#R-中的应用程序接口" class="headerlink" title="R 中的应用程序接口"></a>R 中的应用程序接口</h2><p>在 R 中，Prophet 使用普通的模型拟合接口。Prophet 提供了一个 <code>prophet</code>  函数去拟合模型并且返回一个模型对象，可以对这个模型对象执行“预测”（ <code>predict</code> ）和“绘图”（ <code>plot</code> ）操作。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在 R 中载入包</span></div><div class="line"><span class="keyword">library</span>(prophet)</div><div class="line"><span class="keyword">library</span>(dplyr)</div></pre></td></tr></table></figure>
<p>首先，我们从 <code>example_wp_peyton_manning.csv</code> 文件中读入数据集并构建一个变量储存数据集。就像在 Python 中的应用程序接口使用教程一样，该数据集分为两列： <code>ds</code> 储存的是日期， <code>y</code> 储存的是数值变量（<em>注：</em>对佩顿 · 曼宁维基百科主页日访问量取对数处理）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 读入数据集，并对日访问量 y 取对数处理</span></div><div class="line">df &lt;- read.csv(<span class="string">'./examples/example_wp_peyton_manning.csv'</span>) %&gt;%</div><div class="line">  mutate(y = log(y))</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_6.png" alt="2-1"><br><br></div>

<p>使用 <code>prophet</code> 函数去拟合模型，将历史数据集作为第一个参数，其余额外的参数将会控制 Prophet 如何拟合模型。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 拟合模型</span></div><div class="line">m &lt;- prophet(df)</div></pre></td></tr></table></figure>
<p>预测将会建立在一列包含日期 <code>ds</code> 的数据框基础上来预测指定日期的数据。 <code>make_future_dataframe</code> 函数使用模型对象和一段待预测的时期去构建一个相应的包含待预测日期的数据框。默认情况下，该函数将会自动包含历史数据的日期，因此可用来分析训练集的拟合效果。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建待预测日期数据框，periods = 365 代表除历史数据的日期外再往后推 365 天</span></div><div class="line">future &lt;- make_future_dataframe(m, periods = <span class="number">365</span>)</div><div class="line">tail(future)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_7.png" alt="2-2"><br><br></div>

<p>如同 R 中拟合模型的步骤一样，使用通用的 <code>predict</code> 函数来预测数据。预测结果 <code>forecast</code> 对象是包含了预测值 <code>yhat</code> 的数据框，此外，还有其余的列用来储存估计的置信区间和季节因子。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测数据集</span></div><div class="line">forecast &lt;- predict(m, future)</div><div class="line">tail(forecast[c(<span class="string">'ds'</span>, <span class="string">'yhat'</span>, <span class="string">'yhat_lower'</span>, <span class="string">'yhat_upper'</span>)])</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_8.png" alt="2-3"><br><br></div>

<p>可通过模型和预测结果，使用通用的 <code>plot</code> 函数去展示预测结果。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示预测结果</span></div><div class="line">plot(m, forecast)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_9.png" alt="2-4"><br><br></div>

<p>使用 <code>prophet_plot_components</code> 函数去展示预测中的趋势、周效应和年度效应。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 预测的成分分析绘图，展示预测中的趋势、周效应和年度效应</span></div><div class="line">prophet_plot_components(m, forecast)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="Prophet1_10.png" alt="2-5"><br><br></div>



<p><em>注：</em> Windows 系统语言设置为中文的话，会导致 R 输出成分分析图时，周效应无法正常显示，可在 R 中使用下列代码将环境改为英文：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Sys.setlocale(<span class="string">"LC_ALL"</span>,<span class="string">"English"</span>)</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a>    </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本使用说明教程主要翻译整理自 &lt;a href=&quot;
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NumPy 学习日志之数组篇</title>
    <link href="https://vectorf.github.io/2017/03/08/20170308-NumPy%20%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://vectorf.github.io/2017/03/08/20170308-NumPy 学习日志/</id>
    <published>2017-03-08T08:30:30.000Z</published>
    <updated>2017-03-12T05:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="http://ofa07l4yq.bkt.clouddn.com/numpy.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本学习日志主要来源于 <a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="external">Tentative_NumPy_Tutorial</a></p>
<p>以及其译文 <a href="http://hialex.cn/2014/05/22/(%E8%AF%91)NumPy%E6%95%99%E7%A8%8B(%E4%B8%80)/" target="_blank" rel="external">“(译) NumPy 教程(一)”</a> （<em>注：</em>纠正了其中的几处错误）</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>NumPy 中的主要操作对象是多维数组。</li>
<li>所有的元素都是同类型 (通常数字)，每个元素通过一个正整数构成的元组来索引。</li>
<li>在 NumPy 中，维等价于<em>轴</em>，轴的的数量被称为<em>阶</em>。</li>
</ul>
<p>举个例子，一个在三维空间中的点，它的坐标为表示为 [1，2，1]，则它是一个阶为 1 的数组，因为它只有一个轴，这个轴的长度为 3。<br>下面所示的数组是一个阶为 2 的数组 (2 维数组)。第一维的长度为 2，第二维的长度为 3.(<em>注</em>：第一维为最外层的数组)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[<span class="number">1.</span>,<span class="number">0.</span>,<span class="number">0.</span>],</div><div class="line">[<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">2.</span>]]</div></pre></td></tr></table></figure>
<h2 id="ndarray-概念："><a href="#ndarray-概念：" class="headerlink" title="ndarray 概念："></a>ndarray 概念：</h2><p>Numpy 中的数组类命名为 <code>ndarray</code>，别名为 <code>array</code>。<br>需要知道的是 NumPy 中的数组类<code>numpy.array</code>与 python 标准库中的数组类<code>array.array</code>是不一样的，后者只能处理一维的数组而且提供的操作函数很少。下面列举在 ndarray 类中比较重要的属性：</p>
<ul>
<li><p>ndarray.ndim</p>
<p>数组的轴数 (维数)，在 python 中，轴数也被称为 <em>rank</em>。</p>
</li>
</ul>
<ul>
<li><p>ndarray.shape</p>
<p>数组的维 (轴)。shape 是一个由整数组成的元组，每一个整数代表了数组中每一维的长度。例如一个 n 行 m 列的矩阵 (<em>注：</em>以行为最外层的存储元素)，<code>shape</code> 为 <code>(n, m)</code>, 亦即第一维的长度为 n，第二维的长度为 m。所以 <code>shape</code> 的长度等于 <code>ndarray.ndim</code>。</p>
</li>
</ul>
<ul>
<li><p>ndarray.size</p>
<p>数组的元素个数，等于 <code>shape</code> 元组中每个元素的乘积。</p>
</li>
</ul>
<ul>
<li><p>ndarray.dtype</p>
<p>一个指示数组中元素类型的对象。你可以指定 dtype 为 python 中的任一标准类型，也可以使用 NumPy 中自定义的类型，例如 numpy.int32, numpy.int16 和 numpy.float64 等。</p>
</li>
</ul>
<ul>
<li><p>ndarray.itemsize</p>
<p>数组中每个元素的字节大小。举个例子，一个数组中的元素类型为 <code>float64</code>，那么它的 <code>itemsize</code> 为 8(64/8)，如果元素类型为 <code>complex32</code>，则 <code>itemsize</code> 为 4(32/8)。<code>ndarray.itemsize</code> 等于 <code>ndarray.dtype.itemsize</code>。</p>
</li>
</ul>
<ul>
<li><p>ndarray.data</p>
<p>一个缓冲区保存着数组的所有元素。我们一般不直接用这个属性来访问数组的元素，而是通过数组的索引。</p>
</li>
</ul>
<h4 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</div><div class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</div><div class="line">(<span class="number">2L</span>, <span class="number">5L</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.ndim</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype.name</div><div class="line"><span class="string">'int32'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.itemsize</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.size</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</div><div class="line">numpy.ndarray</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(b)</div><div class="line">numpy.ndarray</div></pre></td></tr></table></figure>
<h3 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h3><p>有多种方法可以创建数组。</p>
<h4 id="1-array"><a href="#1-array" class="headerlink" title="1. array()"></a>1. array()</h4><p>例如，你可以用 python 中的列表或元组作为 <code>array</code> 函数的输入来生成一个数组。数组中的元素类型为输入序列的元素类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</div><div class="line">dtype(<span class="string">'int32'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.dtype</div><div class="line">dtype(<span class="string">'float64'</span>)</div></pre></td></tr></table></figure>
<p><em>常见错误：</em>用这个方法创建数组时常犯的错误是直接输入多个数字参数，而不是提供一个列表作为参数。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.array(1,2,3,4) # 错误</div><div class="line">--------------------------------------------------------------------------</div><div class="line"></div><div class="line">ValueError                               Traceback (most recent call last)</div><div class="line"></div><div class="line">&lt;ipython-input-26-2606e0c2ad94&gt; in &lt;module&gt;()</div><div class="line">----&gt; 1 a = array(1,2,3,4) # 错误</div><div class="line"></div><div class="line"></div><div class="line">ValueError: only 2 non-keyword arguments accepted</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># 正确</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</div><div class="line">dtype(<span class="string">'int32'</span>)</div></pre></td></tr></table></figure>
<p>array 函数会将序列的序列转换为二维的数组，序列的序列的序列转换为三维的数组，以此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([(<span class="number">1.5</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([[ <span class="number">1.5</span>,  <span class="number">2.</span> ,  <span class="number">3.</span> ],</div><div class="line">	   [ <span class="number">4.</span> ,  <span class="number">5.</span> ,  <span class="number">6.</span> ]])</div></pre></td></tr></table></figure>
<p>也可以在数组创建的时候显式的指定数组元素的类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=complex)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">array([[ <span class="number">1.</span>+<span class="number">0.j</span>,  <span class="number">2.</span>+<span class="number">0.j</span>],</div><div class="line">	   [ <span class="number">3.</span>+<span class="number">0.j</span>,  <span class="number">4.</span>+<span class="number">0.j</span>]])</div></pre></td></tr></table></figure>
<h4 id="2-zeros-、ones-、empty"><a href="#2-zeros-、ones-、empty" class="headerlink" title="2. zeros()、ones()、empty()"></a>2. zeros()、ones()、empty()</h4><p>在大多数情况下，数组元素的具体值是未知的，但是数组的大小是已知。因此，NumPy 提供了一些方法来初始化数组，并指定占位符。这样使得我们免于去对数组元素进行循环来初始化。</p>
<ul>
<li><code>zeros</code> 函数创建一个全是 0 的数组，</li>
<li><code>ones</code> 函数创建一个全是 1 的数组，</li>
<li><code>empty</code> 函数创建由随机值组成的数组，随机值的取值取决于内存的相关状态。默认情况下，数组元素的类型为 float64。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.zeros((<span class="number">3</span>, <span class="number">4</span>))</div><div class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">	   [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">	   [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), dtype=np.int16) <span class="comment"># 也可以设置 dtype</span></div><div class="line">array([[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">		[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">		[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]],</div><div class="line"></div><div class="line">	   [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">		[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">		[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]], dtype=int16)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.empty((<span class="number">2</span>, <span class="number">3</span>)) <span class="comment"># 未初始化，输出值是随机的</span></div><div class="line">array([[  <span class="number">8.39544566e-316</span>,   <span class="number">8.41108383e-316</span>,   <span class="number">8.41108660e-316</span>],</div><div class="line">       [  <span class="number">8.41108936e-316</span>,   <span class="number">8.41109213e-316</span>,   <span class="number">8.34415493e-316</span>]])</div></pre></td></tr></table></figure>
<h4 id="3-range"><a href="#3-range" class="headerlink" title="3. range()"></a>3. range()</h4><p>为了创建一个等差的序列，NumPy 提供了类似于 <code>range</code> 的方法，不同的在于，它返回的是一个数组而不是列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>)</div><div class="line">array([<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span>)   <span class="comment"># 接受浮点类型的参数</span></div><div class="line">array([ <span class="number">0.</span> ,  <span class="number">0.3</span>,  <span class="number">0.6</span>,  <span class="number">0.9</span>,  <span class="number">1.2</span>,  <span class="number">1.5</span>,  <span class="number">1.8</span>])</div></pre></td></tr></table></figure>
<p>如果在 <code>arange</code> 中使用浮点类型的参数，通常不太可能判断出它到底返回了多少个值，这是由于浮点数精度有限。因此，所以更推荐使用 <code>linspace</code> 函数，这个函数接收一个参数代表我们想要元素的个数，而不是指定步长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)   <span class="comment"># 生成 9 个数，从 0 到 2</span></div><div class="line">array([ <span class="number">0.</span>  ,  <span class="number">0.25</span>,  <span class="number">0.5</span> ,  <span class="number">0.75</span>,  <span class="number">1.</span>  ,  <span class="number">1.25</span>,  <span class="number">1.5</span> ,  <span class="number">1.75</span>,  <span class="number">2.</span>  ])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)   <span class="comment"># 在分析函数的很多点值时很有用</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = np.sin(x)</div></pre></td></tr></table></figure>
<p><code>numpy</code>库中的部分函数：array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, rand,randn, fromfunction, fromfile。</p>
<h3 id="二、打印数组"><a href="#二、打印数组" class="headerlink" title="二、打印数组"></a>二、打印数组</h3><p>当你打印一个数组时，NumPy 会显示成类似于一个嵌套的表，但是有着固定的布局。</p>
<ul>
<li>最后一个轴中的元素从左到右打印</li>
<li>第二个轴至最后一个轴的元素从上到下打印</li>
<li>其余的同样是从上到下打印，但其中的每一元素以空行间隔</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">6</span>)  <span class="comment"># 1 维数组</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</div><div class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>) <span class="comment">#  2 维数组</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b</div><div class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</div><div class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</div><div class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</div><div class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> c</div><div class="line">[[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</div><div class="line">  [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</div><div class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</div><div class="line"></div><div class="line"> [[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</div><div class="line">  [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</div><div class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]]</div></pre></td></tr></table></figure>
<p>如果一个数组太大导致不能打印出来，那么 NumPy 会自动跳过数组的中间部分，从而只打印边角的部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> np.arange(<span class="number">10000</span>)</div><div class="line">[   <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span> ..., <span class="number">9997</span> <span class="number">9998</span> <span class="number">9999</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>)</div><div class="line">[[   <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span> ...,   <span class="number">97</span>   <span class="number">98</span>   <span class="number">99</span>]</div><div class="line"> [ <span class="number">100</span>  <span class="number">101</span>  <span class="number">102</span> ...,  <span class="number">197</span>  <span class="number">198</span>  <span class="number">199</span>]</div><div class="line"> [ <span class="number">200</span>  <span class="number">201</span>  <span class="number">202</span> ...,  <span class="number">297</span>  <span class="number">298</span>  <span class="number">299</span>]</div><div class="line"> ..., </div><div class="line"> [<span class="number">9700</span> <span class="number">9701</span> <span class="number">9702</span> ..., <span class="number">9797</span> <span class="number">9798</span> <span class="number">9799</span>]</div><div class="line"> [<span class="number">9800</span> <span class="number">9801</span> <span class="number">9802</span> ..., <span class="number">9897</span> <span class="number">9898</span> <span class="number">9899</span>]</div><div class="line"> [<span class="number">9900</span> <span class="number">9901</span> <span class="number">9902</span> ..., <span class="number">9997</span> <span class="number">9998</span> <span class="number">9999</span>]]</div></pre></td></tr></table></figure>
<p>如果想强制 NumPy 打印整个数组，你可以通过 <code>set_printoptions</code> 来改变打印的设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>set_printoptions(threshold=<span class="string">'nan'</span>)</div></pre></td></tr></table></figure>
<h3 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h3><h4 id="1-算术运算"><a href="#1-算术运算" class="headerlink" title="1. 算术运算"></a>1. 算术运算</h4><p>array 的算术运算是元素级别的运算，将会创建一个新的数组并返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = a-b</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">array([<span class="number">20</span>, <span class="number">29</span>, <span class="number">38</span>, <span class="number">47</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b ** <span class="number">2</span></div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span>*np.sin(a)</div><div class="line">array([ <span class="number">9.12945251</span>, <span class="number">-9.88031624</span>,  <span class="number">7.4511316</span> , <span class="number">-2.62374854</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a &lt; <span class="number">35</span></div><div class="line">array([ <span class="keyword">True</span>,  <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>], dtype=bool)</div></pre></td></tr></table></figure>
<h4 id="2-乘积运算：-和-dot"><a href="#2-乘积运算：-和-dot" class="headerlink" title="2. 乘积运算：* 和 dot()"></a>2. 乘积运算：<code>*</code> 和 <code>dot()</code></h4><p>跟其他很多的矩阵语言不一样，在 NumPy 中，乘积 <code>*</code> 是支持元素级别的的操作。而矩阵的乘积则是通过 <code>dot</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([</div><div class="line"><span class="meta">... </span>   [<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]</div><div class="line">...])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array([</div><div class="line"><span class="meta">... </span>   [<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">...])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>A * B   <span class="comment"># 元素级别的乘积</span></div><div class="line">array([[<span class="number">2</span>, <span class="number">0</span>],</div><div class="line">	   [<span class="number">0</span>, <span class="number">4</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>A.dot(B)   <span class="comment"># 矩阵乘积方法一</span></div><div class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(A,B)   <span class="comment"># 矩阵乘积方法二</span></div><div class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</div></pre></td></tr></table></figure>
<h4 id="3-和"><a href="#3-和" class="headerlink" title="3. += 和  *="></a>3. <code>+=</code> 和  <code>*=</code></h4><p>一些操作像 <code>+=</code> 和 <code>*=</code>，会改变原数组的值而不是创建一个新的数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = ones((<span class="number">2</span>,<span class="number">3</span>), dtype=int)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = random.random((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a *= <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],</div><div class="line">	   [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b += a</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([[ <span class="number">3.87955932</span>,  <span class="number">3.08319278</span>,  <span class="number">3.69534205</span>],</div><div class="line">	   [ <span class="number">3.18845592</span>,  <span class="number">3.03853862</span>,  <span class="number">3.96338872</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a += b   # b 不会被自动转换成整数型</div><div class="line">&gt;&gt;&gt; a</div><div class="line">--------------------------------------------------------------------------</div><div class="line"></div><div class="line">TypeError                                Traceback (most recent call last)</div><div class="line"></div><div class="line">&lt;ipython-input-63-7e3386c71838&gt; in &lt;module&gt;()</div><div class="line">----&gt; 1 a += b   # b 不会被自动转换成整数型</div><div class="line">	  2 a</div><div class="line"></div><div class="line"></div><div class="line">TypeError: Cannot cast ufunc add output from dtype('float64') to dtype('int32') with casting rule 'same_kind'</div></pre></td></tr></table></figure>
<p>当对不同类型的数组进行运算操作时，结果返回的数组类型由更精确的一方决定（被称为<em>向上对齐</em>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones(<span class="number">3</span>,dtype=np.int32)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.linspace(<span class="number">0</span>,pi,<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.dtype.name</div><div class="line"><span class="string">'float64'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = a+b</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">array([ <span class="number">1.</span>        ,  <span class="number">2.57079633</span>,  <span class="number">4.14159265</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.dtype.name</div><div class="line"><span class="string">'float64'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = np.exp(c*<span class="number">1j</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">array([ <span class="number">0.54030231</span>+<span class="number">0.84147098j</span>, <span class="number">-0.84147098</span>+<span class="number">0.54030231j</span>,</div><div class="line">	   <span class="number">-0.54030231</span><span class="number">-0.84147098j</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.dtype.name</div><div class="line"><span class="string">'complex128'</span></div></pre></td></tr></table></figure>
<h4 id="4-sum-、min-、max"><a href="#4-sum-、min-、max" class="headerlink" title="4. sum()、min()、max()"></a>4. <code>sum()</code>、<code>min()</code>、<code>max()</code></h4><p>许多的一元操作被实现成 <code>ndarray</code> 类中的一个方法，例如计算数组中所有元素的和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([[ <span class="number">0.31080239</span>,  <span class="number">0.86650424</span>,  <span class="number">0.63788462</span>],</div><div class="line">	   [ <span class="number">0.30848747</span>,  <span class="number">0.56321876</span>,  <span class="number">0.22655507</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.sum()</div><div class="line"><span class="number">2.9134525563393563</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.min()</div><div class="line"><span class="number">0.22655506980153794</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.max()</div><div class="line"><span class="number">0.86650424285907612</span></div></pre></td></tr></table></figure>
<p>在默认情况下，这些操作会把数组当成是由数字组成的列表，忽略它们的轴。但是，我们可以通过指定 <code>axis</code> 参数来使操作应用到特定的维上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</div><div class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</div><div class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.sum(axis=<span class="number">0</span>)  <span class="comment"># 每一列的和</span></div><div class="line">array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.min(axis=<span class="number">1</span>) <span class="comment"># 每一行的最小值</span></div><div class="line">array([<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.cumsum(axis=<span class="number">1</span>) <span class="comment"># 每行元素累计相加的和</span></div><div class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>],</div><div class="line">	   [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">15</span>, <span class="number">22</span>],</div><div class="line">	   [ <span class="number">8</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">38</span>]])</div></pre></td></tr></table></figure>
<h3 id="四、全局函数"><a href="#四、全局函数" class="headerlink" title="四、全局函数"></a>四、全局函数</h3><p>NumPy 提供了数学函数如 sin， cos 和 exp。在 NumPy 中，这些函数被称为全局函数 (<code>ufunc</code>)。在 NumPy 中，这些函数对数组进行元素级别的操作，生成一个数组作为输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.arange(<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>B</div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(B)</div><div class="line">array([ <span class="number">1.</span>        ,  <span class="number">2.71828183</span>,  <span class="number">7.3890561</span> ])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(B)</div><div class="line">array([ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">1.41421356</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>C = np.array([<span class="number">2.</span>, <span class="number">-1.</span>, <span class="number">4.</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>np.add(B, C)</div><div class="line">array([ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>])</div></pre></td></tr></table></figure>
<p>其他的一些全局函数：all, alltrue, any, apply along axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose, var, vdot, vectorize, where。</p>
<h3 id="五、索引、切片和迭代"><a href="#五、索引、切片和迭代" class="headerlink" title="五、索引、切片和迭代"></a>五、索引、切片和迭代</h3><h4 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h4><p><strong>一维数组</strong> 可以像 python 中的列表和其他序列一样进行索引，切片和迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>)**<span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">8</span>,  <span class="number">27</span>,  <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>]</div><div class="line">array([ <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">6</span>:<span class="number">2</span>] = <span class="number">-1000</span> <span class="comment"># 从开始位置0到位置6(不包括)，每两个元素设为-1000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([<span class="number">-1000</span>,     <span class="number">1</span>, <span class="number">-1000</span>,    <span class="number">27</span>, <span class="number">-1000</span>,   <span class="number">125</span>,   <span class="number">216</span>,   <span class="number">343</span>,   <span class="number">512</span>,   <span class="number">729</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>]   <span class="comment"># 反转a</span></div><div class="line">array([  <span class="number">729</span>,   <span class="number">512</span>,   <span class="number">343</span>,   <span class="number">216</span>,   <span class="number">125</span>, <span class="number">-1000</span>,    <span class="number">27</span>, <span class="number">-1000</span>,     <span class="number">1</span>, <span class="number">-1000</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</div><div class="line"><span class="meta">... </span>   <span class="keyword">print</span> i**(<span class="number">1</span>/<span class="number">3.</span>)</div><div class="line">nan</div><div class="line"><span class="number">1.0</span></div><div class="line">nan</div><div class="line"><span class="number">3.0</span></div><div class="line">nan</div><div class="line"><span class="number">5.0</span></div><div class="line"><span class="number">6.0</span></div><div class="line"><span class="number">7.0</span></div><div class="line"><span class="number">8.0</span></div><div class="line"><span class="number">9.0</span></div></pre></td></tr></table></figure>
<h4 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h4><p><strong>多维数组</strong> 可以在每个轴通过一个索引来定位元素，每一轴的索引值以逗号间隔。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></div><div class="line"><span class="meta">... </span>  <span class="keyword">return</span> <span class="number">10</span>*x+y</div><div class="line"></div><div class="line"><span class="comment"># numpy 中的 fromfunction </span></div><div class="line"><span class="comment"># 按一个5*4的数组的每一个位置的横纵坐标作为函数f的输入参数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=int) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b</div><div class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</div><div class="line">	   [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</div><div class="line">	   [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</div><div class="line">	   [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</div><div class="line">	   [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="number">23</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>:<span class="number">5</span>,<span class="number">1</span>] <span class="comment"># 第二列中每一行的值</span></div><div class="line">array([ <span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">41</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[:,<span class="number">1</span>] <span class="comment"># 等价于上一个语句</span></div><div class="line">array([ <span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">41</span>])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>:<span class="number">3</span>,:] <span class="comment"># 第二行和第三行中每一列的值</span></div><div class="line">array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</div><div class="line">	   [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]])</div></pre></td></tr></table></figure>
<p>当少于轴数的索引值给出时，其余未给出索引的轴被当作是全部保留。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">-1</span>]  <span class="comment"># 最后一行</span></div><div class="line">array([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>])</div></pre></td></tr></table></figure>
<p>在 <code>b[i]</code> 方括号中的表达式会当作是一个 <code>i</code> 后面跟着足够多个”<code>:</code>” 来表示剩余的轴。NumPy 也允许你使用点点点来表示，像这样 <code>b[i,…]</code>。<br>这个点点点 (<code>…</code>) 表示有足够多个”<code>:</code>”来表示剩余的索引值。</p>
<p>如果 <code>x</code> 是一个 rank 为 5 的数组(即轴数为 5)，则：</p>
<ul>
<li><code>x[1,2,…]</code> 等价于 <code>x[1,2,:,:,:]</code></li>
<li><code>x[…,3]</code> 等价于 <code>x[:,:,:,:,3]</code></li>
<li><code>x[4,…,5,:]</code> 等价于 <code>x[4,:,:,5,:]</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([      <span class="comment"># 三维数组</span></div><div class="line"><span class="meta">... </span>   [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>]],</div><div class="line"><span class="meta">... </span>   [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],[<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]</div><div class="line">...])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape</div><div class="line">(<span class="number">2L</span>, <span class="number">2L</span>, <span class="number">3L</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">1</span>,...]   <span class="comment"># 等价于 c[1,:,:]</span></div><div class="line">array([[<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</div><div class="line">	   [<span class="number">110</span>, <span class="number">112</span>, <span class="number">113</span>]])</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c[...,<span class="number">2</span>]   <span class="comment"># 等价于 c[:,:,2]</span></div><div class="line">array([[  <span class="number">2</span>,  <span class="number">13</span>],</div><div class="line">	   [<span class="number">102</span>, <span class="number">113</span>]])</div></pre></td></tr></table></figure>
<h4 id="3-多维数组的迭代"><a href="#3-多维数组的迭代" class="headerlink" title="3. 多维数组的迭代"></a>3. 多维数组的迭代</h4><p>对多维数组进行 <strong>迭代</strong> 是相对于第一个轴进行遍历完成的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> b:</div><div class="line"><span class="meta">... </span>   <span class="keyword">print</span> row</div><div class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</div><div class="line">[<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</div><div class="line">[<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</div><div class="line">[<span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]</div><div class="line">[<span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span>]</div></pre></td></tr></table></figure>
<p>然而，如果你想对每一个元素进行迭代，你可以使用 <code>flat</code> 属性，它是包含数组中每个元素的迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</div><div class="line"><span class="meta">... </span>   <span class="keyword">print</span> element,</div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span></div></pre></td></tr></table></figure>
<p>同样，相关的函数有： newaxis, ndenumerate, indices, index exp。</p>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ofa07l4yq.bkt.clouddn.com/numpy.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquo
    
    </summary>
    
      <category term="Python" scheme="https://vectorf.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Numpy" scheme="https://vectorf.github.io/tags/Numpy/"/>
    
      <category term="ndarray" scheme="https://vectorf.github.io/tags/ndarray/"/>
    
      <category term="数组" scheme="https://vectorf.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Prophet 之安装篇</title>
    <link href="https://vectorf.github.io/2017/03/08/20170308-Prophet%20%E4%B9%8B%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>https://vectorf.github.io/2017/03/08/20170308-Prophet 之安装篇/</id>
    <published>2017-03-08T08:30:30.000Z</published>
    <updated>2018-01-31T14:54:25.734Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="http://ofa07l4yq.bkt.clouddn.com/Prophet.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>本安装文档主要翻译整理自 <a href="https://facebookincubator.github.io/prophet/docs/installation.html" target="_blank" rel="external">Prophet Installation</a> 官方安装文档。</p>
</blockquote>
<h2 id="在-R-上安装-Prophet"><a href="#在-R-上安装-Prophet" class="headerlink" title="在 R 上安装 Prophet"></a>在 R 上安装 Prophet</h2><h3 id="一、Windows-系统安装-Prophet-前的准备工作"><a href="#一、Windows-系统安装-Prophet-前的准备工作" class="headerlink" title="一、Windows 系统安装 Prophet 前的准备工作"></a>一、Windows 系统安装 Prophet 前的准备工作</h3><p>如果是 Windows 系统，需要按照 <a href="https://github.com/stan-dev/rstan/wiki/Installing-RStan-on-Windows" target="_blank" rel="external">rstan</a> 提供的教程给 R 安装一个编译器。其中，最为关键的一步就是先安装 <a href="http://cran.r-project.org/bin/windows/Rtools/" target="_blank" rel="external">Rtools</a> 。</p>
<h4 id="1-安装-R-和-RStudio"><a href="#1-安装-R-和-RStudio" class="headerlink" title="1. 安装 R 和 RStudio"></a>1. 安装 R 和 RStudio</h4><h4 id="2-安装-Rtools-，确保其安装目录已添加至系统环境变量中。"><a href="#2-安装-Rtools-，确保其安装目录已添加至系统环境变量中。" class="headerlink" title="2. 安装 Rtools ，确保其安装目录已添加至系统环境变量中。"></a>2. 安装 Rtools ，确保其安装目录已添加至系统环境变量中。</h4><p>假如 Rtools 安装在 C 盘，则运行<code>Sys.getenv(&#39;PATH&#39;)</code>后，输出应包含如下所示的结果（<em>注：</em>原文教程中结果为”C:\Rtools\bin;C:\Rtools\gcc-4.6.3\bin;”）；运行<code>system(&#39;g++ -v&#39;)</code>和<code>system(&#39;where make&#39;)</code>后输出结果正常，如下所示。</p>
<p>否则，请确保 Rtools 安装目录已添加至系统环境变量中。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; Sys.getenv(<span class="string">'PATH'</span>)</div><div class="line">C:\\Rtools\\bin;C:\\Rtools\\mingw_64\\bin;</div><div class="line">&gt; system(<span class="string">'g++ -v'</span>)</div><div class="line">Using built-<span class="keyword">in</span> specs.</div><div class="line">COLLECT_GCC=C:\Rtools\mingw_64\bin\G__~<span class="number">1.</span>EXE</div><div class="line"><span class="comment"># 已省略部分输出结果</span></div><div class="line">gcc version <span class="number">4.9</span><span class="number">.3</span> (x86_64-posix-seh, Built by MinGW-W64 project) </div><div class="line">&gt; system(<span class="string">'where make'</span>)</div><div class="line">C:\Rtools\bin\make.exe</div></pre></td></tr></table></figure>
<h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h4><p><del>非必须操作</del>，不会影响 RStan 正常工作，但强烈推荐。</p>
<ul>
<li>创建一个 Makevars 文件，代码如下：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dotR &lt;- file.path(Sys.getenv(<span class="string">"HOME"</span>), <span class="string">".R"</span>)</div><div class="line"><span class="keyword">if</span> (!file.exists(dotR)) </div><div class="line">  dir.create(dotR)</div><div class="line">M &lt;- file.path(dotR, <span class="string">"Makevars"</span>)</div><div class="line"><span class="keyword">if</span> (!file.exists(M)) </div><div class="line">  file.create(M)</div><div class="line">cat(<span class="string">"\nCXXFLAGS=-O3 -mtune=native -march=native -Wno-unused-variable -Wno-unused-function"</span>, </div><div class="line">    file = M, sep = <span class="string">"\n"</span>, append = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<ul>
<li>如果你使用的是 Rtools33 （或更高版本），则需要运行下列代码：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat(<span class="string">'Sys.setenv(BINPREF = "C:/Rtools/mingw_$(WIN)/bin/")'</span>,</div><div class="line">    file = file.path(Sys.getenv(<span class="string">"HOME"</span>), <span class="string">".Rprofile"</span>), </div><div class="line">    sep = <span class="string">"\n"</span>, append = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<ul>
<li>如果你使用的 g++ 版本号在 6 或以上，且希望关掉和 Stan 不相关的一些警告信息，可以运行下列代码：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat(<span class="string">"\nCXXFLAGS += -Wno-ignored-attributes -Wno-deprecated-declarations"</span>, </div><div class="line">    file = M, sep = <span class="string">"\n"</span>, append = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<ul>
<li>确认配置成功，可运行下列代码：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看配置的信息</span></div><div class="line">cat(readLines(M), sep = <span class="string">"\n"</span>)</div><div class="line"><span class="comment"># 或是找到该配置文件的路径，自行打开查看</span></div><div class="line">cat(M)</div></pre></td></tr></table></figure>
<h4 id="4-安装-RStan"><a href="#4-安装-RStan" class="headerlink" title="4. 安装 RStan"></a>4. 安装 RStan</h4><ul>
<li>安装最新版本的 RStan 及其依赖包，代码如下：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 注意: 如果 https 下载不成功，可改为 http</span></div><div class="line"><span class="comment"># 确保 dependencies=TRUE ，安装依赖包</span></div><div class="line">install.packages(<span class="string">"rstan"</span>, repos = <span class="string">"https://cloud.r-project.org/"</span>, dependencies=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<ul>
<li>如果上述过程均失败，可通过下列代码按源码安装：</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 注意: 可根据你想使用的内核数来更改数字“4”</span></div><div class="line">Sys.setenv(MAKEFLAGS = <span class="string">"-j4"</span>) </div><div class="line">install.packages(<span class="string">"rstan"</span>, type = <span class="string">"source"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>安装完成后，<strong>重启 R</strong> 。并在载入 RStan 前，确认没有旧版本 RStan 所创建（可能是自动创建）的产物已被载入 R 中。</li>
<li>通过运行如下代码，确认工具链已生效，代码应当返回值<code>10</code>:</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fx &lt;- inline::cxxfunction( signature(x = <span class="string">"integer"</span>, y = <span class="string">"numeric"</span> ) , <span class="string">'</span></div><div class="line">    return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;</div><div class="line">' )</div><div class="line">fx( <span class="number">2L</span>, <span class="number">5</span> ) <span class="comment"># 应当返回值 10</span></div></pre></td></tr></table></figure>
<p><em>注：</em>以上命令都是在 R 中输入运行的。</p>
<h3 id="二、安装-Prophet-包"><a href="#二、安装-Prophet-包" class="headerlink" title="二、安装 Prophet 包"></a>二、安装 Prophet 包</h3><p>在 R 中运行如下代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># R </span></div><div class="line">install.packages(<span class="string">'prophet'</span>)</div></pre></td></tr></table></figure>
<h2 id="在-Python-上安装-Prophet"><a href="#在-Python-上安装-Prophet" class="headerlink" title="在 Python 上安装 Prophet"></a>在 Python 上安装 Prophet</h2><h3 id="一、安装-Prophet-前的准备工作"><a href="#一、安装-Prophet-前的准备工作" class="headerlink" title="一、安装 Prophet 前的准备工作"></a>一、安装 Prophet 前的准备工作</h3><p>Python 中的 Prophet 最主要的依赖库是 <code>pystan</code>。不管什么系统，都需按照 <a href="http://pystan.readthedocs.io/en/latest/installation_beginner.html" target="_blank" rel="external">安装教程</a> 先安装<code>pystan</code>。</p>
<h4 id="1-安装-Python"><a href="#1-安装-Python" class="headerlink" title="1. 安装 Python"></a>1. 安装 Python</h4><p>推荐使用 Anaconda 。Anaconda 是一个开源的 Python 发行版本，内置<code>conda</code>来实现<code>pip</code>库管理的功能。</p>
<h4 id="2-安装-Pthon-的依赖库"><a href="#2-安装-Pthon-的依赖库" class="headerlink" title="2. 安装 Pthon 的依赖库"></a>2. 安装 Pthon 的依赖库</h4><p>如果你使用的是 Anaconda , numpy 和 cython 库已经内置在其中。但是以防万一，你也可以使用<code>conda</code>去安装它们：</p>
<ul>
<li><p>打开一个命令行程序</p>
</li>
<li><p>使用<code>conda install numpy</code>命令去安装 numpy ; 使用<code>conda install cython</code>命令去安装 cython</p>
</li>
</ul>
<h4 id="3-安装-PyStan-库"><a href="#3-安装-PyStan-库" class="headerlink" title="3. 安装 PyStan 库"></a>3. 安装 PyStan 库</h4><p>  Mac/Linux 用户按照下述步骤安装 PyStan 即可。</p>
<ul>
<li>打开一个命令行程序</li>
<li><p>使用<code>pip install pystan</code>去安装 PyStan</p>
<p>Windows 用户请按照“Windows 系统安装 PyStan”中的步骤进行安装。</p>
</li>
</ul>
<h4 id="Windows-系统安装-PyStan"><a href="#Windows-系统安装-PyStan" class="headerlink" title="** Windows 系统安装 PyStan"></a>** Windows 系统安装 PyStan</h4><p>如果是 Windows 系统，在安装 PyStan 前需要按照 <a href="http://pystan.readthedocs.io/en/latest/windows.html" target="_blank" rel="external">安装教程</a> 给 PyStan 安装一个编译器。其中，最为关键的一步就是先安装  <a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="external">C++ 编译器</a> 。</p>
<p>Windows 系统下使用 PyStan 有下列<em>注意事项</em>：</p>
<ol>
<li><p>需要使用 Python 3.5 或更高版本</p>
</li>
<li><p>抽取样本时，必须使用<code>n_jobs=1</code>（Windows 系统下的 PyStan 不能使用并行多线程运算）</p>
</li>
<li><p>安装 C++ 编译器</p>
<p>进入 <a href="http://landinghub.visualstudio.com/visual-cpp-build-tools" target="_blank" rel="external">Visual C++ Build Tools</a> 网页，点击“Download Visual C++ Build Tools 2015”。</p>
<p>如果你遇到了安装的问题，可以去 Python维基下的 <a href="https://wiki.python.org/moin/WindowsCompilers" target="_blank" rel="external">Windows Compilers</a> 寻求解决办法。</p>
<p>如果你使用的 Windows 7 系统，可能需要在安装 Visual C++ Build Tools 下先更新 Microsoft .NET Framework 。</p>
</li>
<li><p>安装 PyStan</p>
<p>打开命令行程序，输入下列命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pystan</div></pre></td></tr></table></figure>
<p>可通过在 python 中输入下列抽样的代码，验证安装成功：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pystan</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>model_code = <span class="string">'parameters &#123;real y;&#125; model &#123;y ~ normal(0,1);&#125;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>model = pystan.StanModel(model_code=model_code)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y = model.sampling(n_jobs=<span class="number">1</span>).extract()[<span class="string">'y'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y.mean()  <span class="comment"># 结果应当在 0 附近</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二、安装-Prophet"><a href="#二、安装-Prophet" class="headerlink" title="二、安装 Prophet"></a>二、安装 Prophet</h3><p>使用命令行程序运行下列<code>pip</code>命令安装即可：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># bash</div><div class="line">$ pip install fbprophet</div></pre></td></tr></table></figure>
<h4 id="Ubuntu-系统安装注意事项"><a href="#Ubuntu-系统安装注意事项" class="headerlink" title="Ubuntu 系统安装注意事项"></a>Ubuntu 系统安装注意事项</h4><ol>
<li><p>在 Ubuntu 16.04 系统下，使用系统内置的 python 2.7 安装上 fbprophet 后，导入 <code>import fbprophet</code> 时提示需要安装 <code>matplotlib</code> 库和 <code>python-tk</code>。打开一个终端，输入下列命令即可：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~ sudo pip install matplotlib</div><div class="line">~ sudo apt-get install tk-dev</div><div class="line">~ sudo apt-get install python-tk</div></pre></td></tr></table></figure>
</li>
<li><p>Ubuntu 16.04 系统使用内置的 python 可以成功安装 fbprophet ，但使用 Anaconda 成功安装 PyStan 库后，检验代码无法成功运行， Prophet 库也无法正确安装：</p>
<p>运行检验代码后的错误信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line"></div><div class="line">  File <span class="string">"&lt;ipython-input-28-15d1abb9774a&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    model = pystan.StanModel(model_code=model_code)</div><div class="line"></div><div class="line">  File <span class="string">"/home/username/anaconda2/lib/python2.7/site-packages/pystan/model.py"</span>, line <span class="number">315</span>, <span class="keyword">in</span> __init__</div><div class="line">    self.module = load_module(self.module_name, lib_dir)</div><div class="line"></div><div class="line">  File <span class="string">"/home/username/anaconda2/lib/python2.7/site-packages/pystan/model.py"</span>, line <span class="number">54</span>, <span class="keyword">in</span> load_module</div><div class="line">    <span class="keyword">return</span> imp.load_module(module_name, *module_info)</div><div class="line"></div><div class="line">ImportError: /tmp/tmpgc2vTO/stanfit4anon_model_5944bb5b3a93728ca2bf_765485408593311.so: undefined symbol: _ZTVNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEE</div></pre></td></tr></table></figure>
<p>后尝试在 Anaconda 的 Spyder 中将 console 的 python 路径更改为 <code>/usr/bin/python</code> ，运行检验代码仍然报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">    </div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line"></div><div class="line">  File <span class="string">"/usr/local/lib/python2.7/dist-packages/pystan/model.py"</span>, line <span class="number">315</span>, <span class="keyword">in</span> __init__</div><div class="line">    self.module = load_module(self.module_name, lib_dir)</div><div class="line">    </div><div class="line">  File <span class="string">"/usr/local/lib/python2.7/dist-packages/pystan/model.py"</span>, line <span class="number">54</span>, <span class="keyword">in</span> load_module</div><div class="line">    <span class="keyword">return</span> imp.load_module(module_name, *module_info)</div><div class="line"></div><div class="line">ImportError: /home/username/anaconda2/lib/python2<span class="number">.7</span>/site-packages/numexpr/../../../libstdc++.so<span class="number">.6</span>: version `GLIBCXX_3<span class="number">.4</span><span class="number">.20</span><span class="string">' not found (required by /tmp/tmptEazgR/stanfit4anon_model_5944b02c79788fa8ca2bf_7654287730157512986.so)</span></div></pre></td></tr></table></figure>
<p>在网上查询后，发现是由于 Anaconda 中未安装 <code>libgcc</code> 库。打开一个命令行，运行下列代码安装即可：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda install libgcc</div></pre></td></tr></table></figure>
<p>安装 <code>libgcc</code> 库后，就可以成功运行检验代码了。</p>
<p>机缘巧合下，发现安装 <code>libgcc</code> 库后，使用Anaconda 自带的 python ，也可以成功安装 <code>PyStan</code> 和 <code>fbprophet</code> 了。遂将 Spyder 中 console 的 python 路径更改为原来默认的。</p>
</li>
</ol>
<h3 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a><em>待解决问题</em></h3><p>Windows 10 系统已安装上 C++ 编译器和 PyStan 库且检验代码成功运行后，无法安装 Prophet 库：</p>
<p>错误信息：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">error: <span class="title">command</span> '<span class="title">C</span>:\\<span class="title">Program</span> <span class="title">Files</span> (<span class="title">x86</span>)\\<span class="title">Microsoft</span> <span class="title">Visual</span> <span class="title">Studio</span> 14.0\\<span class="title">VC</span>\\<span class="title">BIN</span>\\<span class="title">x86_amd64</span>\\<span class="title">cl.exe</span>' <span class="title">failed</span> <span class="title">with</span> <span class="title">exit</span> <span class="title">status</span> 2</span></div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a>     </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ofa07l4yq.bkt.clouddn.com/Prophet.jpg&quot; width=&quot;800&quot; height=&quot;350&quot; alt=&quot;0&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockq
    
    </summary>
    
      <category term="Prophet" scheme="https://vectorf.github.io/categories/Prophet/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="Python" scheme="https://vectorf.github.io/tags/Python/"/>
    
      <category term="Prophet" scheme="https://vectorf.github.io/tags/Prophet/"/>
    
      <category term="时间序列" scheme="https://vectorf.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>要优雅！一行代码搞定 R 语言模型输出！（使用 stargazer 包）</title>
    <link href="https://vectorf.github.io/2017/02/21/20170221-%E8%A6%81%E4%BC%98%E9%9B%85%EF%BC%81%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%20R%20%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA%EF%BC%81%EF%BC%88%E4%BD%BF%E7%94%A8%20stargazer%20%E5%8C%85%EF%BC%89/"/>
    <id>https://vectorf.github.io/2017/02/21/20170221-要优雅！一行代码搞定 R 语言模型输出！（使用 stargazer 包）/</id>
    <published>2017-02-21T08:30:30.000Z</published>
    <updated>2018-01-31T14:50:45.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>使用<code>stargazer</code>包可以将 R 构建的模型结果以<code>LATEX</code>、<code>HTML</code>和<code>ASCII</code>格式输出，方便我们生成标准格式的表格。</p>
<p>再结合<code>rmarkdown</code>，你就可以轻轻松松输出一篇优雅的文章啦~</p>
<p>本文“使用说明”部分主要参考<code>stargazer</code>的<a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" title="stargezer.pdf" target="_blank" rel="external">说明文档</a>。</p>
<hr>
<h2 id="二、安装及加载"><a href="#二、安装及加载" class="headerlink" title="二、安装及加载"></a>二、安装及加载</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"stargazer"</span>)</div><div class="line"><span class="keyword">library</span>(stargazer)</div></pre></td></tr></table></figure>
<hr>
<h2 id="三、使用说明"><a href="#三、使用说明" class="headerlink" title="三、使用说明"></a>三、使用说明</h2><p><em>注：</em> <code>stargazer</code>包的输出结果是相应格式的，例如输出<code>LATEX</code>格式，可以直接将结果粘贴进<code>WinEdt</code>等编辑器中输出表格。下文直接将结果以表格的形式展示。</p>
<p>我们使用 R 中自带的数据集<code>attitude</code>来简要说明<code>stargazer</code>包的用法。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data(<span class="string">"attitude"</span>)</div></pre></td></tr></table></figure>
<p><code>attitude</code>数据集中包括<code>rating</code>、<code>complaints</code>等八个变量：</p>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/0.png" alt="0"><br><br></div>

<h3 id="1-展示数据集的描述性分析和部分数据集内容"><a href="#1-展示数据集的描述性分析和部分数据集内容" class="headerlink" title="1. 展示数据集的描述性分析和部分数据集内容"></a>1. 展示数据集的描述性分析和部分数据集内容</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示数据集的描述性分析</span></div><div class="line">stargazer(attitude,header = <span class="literal">F</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/1.png" alt="1"><br><br></div>

<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 展示attitude数据集的前四行</span></div><div class="line">stargazer(attitude[<span class="number">1</span>:<span class="number">4</span>,], summary=<span class="literal">FALSE</span>, rownames=<span class="literal">FALSE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/2.png" alt="2"><br><br></div>

<p>怎么样？！是不是感觉还不错~</p>
<h3 id="2-展示线性模型结果，并加上表名"><a href="#2-展示线性模型结果，并加上表名" class="headerlink" title="2. 展示线性模型结果，并加上表名"></a>2. 展示线性模型结果，并加上表名</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建线性和Probit模型</span></div><div class="line">linear.1 &lt;- lm(rating ~ complaints + privileges + learning + raises + critical,data=attitude)</div><div class="line">linear.2 &lt;- lm(rating ~ complaints + privileges + learning, data=attitude)</div><div class="line">attitude$high.rating &lt;- (attitude$rating &gt; <span class="number">70</span>)</div><div class="line">probit.model &lt;- glm(high.rating ~ learning + critical + advance, data=attitude,family = binomial(link = <span class="string">"probit"</span>))</div><div class="line"><span class="comment"># 展示模型结果</span></div><div class="line">stargazer(linear.1, linear.2, probit.model, title=<span class="string">"Results"</span>,align=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/3.png" alt="3"><br><br></div>

<p>我们构建了两个线性模型和一个 Probit 模型，并将结果输出。</p>
<p>使用<code>title</code>参数将其命名为“Results”；</p>
<p>使用<code>align</code>参数使数字排列整齐。</p>
<h3 id="3-对模型结果输出做部分调整："><a href="#3-对模型结果输出做部分调整：" class="headerlink" title="3. 对模型结果输出做部分调整："></a>3. 对模型结果输出做部分调整：</h3><ul>
<li>更改变量名；</li>
<li>删除极大似然统计量、残差标准差、F统计量；</li>
<li>删除表中的空行。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stargazer(linear.1, linear.2, probit.model, </div><div class="line">          title=<span class="string">"Regression Results"</span>, align=<span class="literal">TRUE</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          covariate.labels=c(<span class="string">"Handling of Complaints"</span>,<span class="string">"No Special Privileges"</span>,<span class="string">"Opportunity to Learn"</span>,<span class="string">"Performance-Based Raises"</span>,<span class="string">"Too Critical"</span>,<span class="string">"Advancement"</span>),</div><div class="line">          omit.stat=c(<span class="string">"LL"</span>,<span class="string">"ser"</span>,<span class="string">"f"</span>), no.space=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/4.png" alt="4"><br><br></div>

<p>使用<code>dep.var.labels</code>和<code>covariate.lables</code>参数分别将因变量和自变量重命名为容易理解的形式；</p>
<p>使用<code>omit.stat</code>参数控制对数似然比（“LL”）、标准化残差（“ser”）和F统计量（“f”），这三个统计量不在输出结果中展示；</p>
<p>使用<code>no.space</code>参数将输出表格中的空行删去。</p>
<h3 id="4-展示置信区间"><a href="#4-展示置信区间" class="headerlink" title="4. 展示置信区间"></a>4. 展示置信区间</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">targazer(linear.1, linear.2, </div><div class="line">          title=<span class="string">"Regression Results"</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          covariate.labels=c(<span class="string">"Handling of Complaints"</span>,<span class="string">"No Special Privileges"</span>,<span class="string">"Opportunity to Learn"</span>,<span class="string">"Performance-Based Raises"</span>,<span class="string">"Too Critical"</span>,<span class="string">"Advancement"</span>),</div><div class="line">          omit.stat=c(<span class="string">"LL"</span>,<span class="string">"ser"</span>,<span class="string">"f"</span>),</div><div class="line">         ci=<span class="literal">TRUE</span>, ci.level=<span class="number">0.90</span>, single.row=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/5.png" alt="5"><br><br></div>

<p>使用<code>ci</code>和<code>ci.level</code>参数展示90%的置信区间；</p>
<p>使用<code>single.row</code>参数使估计量与置信区间并排展示。</p>
<h3 id="5-调整变量展示顺序，加上样本量，并移除其他统计量"><a href="#5-调整变量展示顺序，加上样本量，并移除其他统计量" class="headerlink" title="5. 调整变量展示顺序，加上样本量，并移除其他统计量"></a>5. 调整变量展示顺序，加上样本量，并移除其他统计量</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stargazer(linear.1, linear.2, title=<span class="string">"Regression Results"</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          order=c(<span class="string">"learning"</span>, <span class="string">"privileges"</span>),</div><div class="line">          keep.stat=<span class="string">"n"</span>, ci=<span class="literal">TRUE</span>, ci.level=<span class="number">0.90</span>, single.row=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/6.png" alt="6"><br><br></div>

<p>使用<code>order</code>参数控制自变量展示的顺序，即将<code>learning</code>和<code>privileges</code>放在表的前两行；</p>
<p>使用<code>keep.stat</code>参数控制要展示的统计量，<code>keep.stat=&quot;n&quot;</code>即只展示样本量的大小，并移除其他统计量。</p>
<h3 id="6-以ASCII格式输出："><a href="#6-以ASCII格式输出：" class="headerlink" title="6. 以ASCII格式输出："></a>6. 以<code>ASCII</code>格式输出：</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stargazer(linear.1, linear.2, type=<span class="string">"text"</span>, title=<span class="string">"Regression Results"</span>,</div><div class="line">          dep.var.labels=c(<span class="string">"Overall Rating"</span>,<span class="string">"High Rating"</span>),</div><div class="line">          covariate.labels=c(<span class="string">"Handling of Complaints"</span>,<span class="string">"No Special Privileges"</span>,<span class="string">"Opportunity to Learn"</span>,<span class="string">"Performance-Based Raises"</span>,<span class="string">"Too Critical"</span>,<span class="string">"Advancement"</span>),</div><div class="line">          omit.stat=c(<span class="string">"LL"</span>,<span class="string">"ser"</span>,<span class="string">"f"</span>), ci=<span class="literal">TRUE</span>, ci.level=<span class="number">0.90</span>, single.row=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/7.png" alt="7"><br><br></div>

<p>使用<code>type</code>参数控制以<code>ASCII</code>格式输出，还可以选择输出<code>HTML</code>格式。默认为<code>LATEX</code>格式。</p>
<p>相应地，将<code>type</code>参数分别设置为<code>text</code>、<code>html</code>、<code>latex</code>即可。</p>
<h3 id="7-展示矩阵"><a href="#7-展示矩阵" class="headerlink" title="7. 展示矩阵"></a>7. 展示矩阵</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">correlation.matrix &lt;-cor(attitude[,c(<span class="string">"rating"</span>,<span class="string">"complaints"</span>,<span class="string">"privileges"</span>)])</div><div class="line">stargazer(correlation.matrix, title=<span class="string">"Correlation Matrix"</span>)</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/8.png" alt="8"><br><br></div>

<p><code>stargazer</code>也可以用来展示向量、矩阵或者数据框的内容。</p>
<p>我们建立了<code>attitude</code>数据集中变量<code>rating</code>、<code>complaints</code>、<code>privileges</code>的相关系数矩阵，并展示出来。</p>
<h3 id="8-自定义变量"><a href="#8-自定义变量" class="headerlink" title="8. 自定义变量"></a>8. 自定义变量</h3><p>我们使用<code>sandwich</code>包来计算异方差-稳健标准误，并将其与默认计算的标准差一同展示。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装及加载"sandwich"包</span></div><div class="line">install.packages(<span class="string">"sandwich"</span>)</div><div class="line"><span class="keyword">library</span>(sandwich)</div><div class="line"><span class="comment"># 计算异方差-稳健标准误</span></div><div class="line">cov&lt;-vcovHC(linear.1,type=<span class="string">"HC"</span>)</div><div class="line">robust.se&lt;-sqrt(diag(cov))</div><div class="line">stargazer(linear.1,linear.1,se=list(<span class="literal">NULL</span>,robust.se),column.labels = c(<span class="string">"default"</span>,<span class="string">"robust"</span>))</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/9.png" alt="9"><br><br></div>

<hr>
<h2 id="四、与-rmarkdown-一起食用"><a href="#四、与-rmarkdown-一起食用" class="headerlink" title="四、与 rmarkdown 一起食用"></a>四、与 <code>rmarkdown</code> 一起食用</h2><p><code>rmarkdown</code>包可直接在<code>RStudio</code>中编辑符合 <code>markdown</code>语法的文档，并兼容<code>LATEX</code>格式。而且可以直接输出成<code>HTML</code>、<code>pdf</code>等格式的文档。</p>
<p>因此，<code>stargazer</code>与<code>rmarkdown</code>一起食用，风味更佳~</p>
<p>首先，你需要在<code>Rstudio</code>中安装<code>rmarkdown</code>。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"rmarkdown"</span>)</div></pre></td></tr></table></figure>
<p>然后，就可以原先新建脚本的地方发现，可以新建一个<code>R Markdown</code>文件啦。</p>
<p>在<code>rmarkdown</code>中，用如下所示的形式来表示代码块：</p>
<div align="center"><br><br><img src="http://ogs78tgts.bkt.clouddn.com/10.png" alt="10"><br><br></div>

<p>注意以下几点：</p>
<ul>
<li>要加上<code>results=&#39;asis&#39;</code>保证输出的是表格，而不是<code>LATEX</code>格式；</li>
<li>参数<code>align</code>失效，不能加上；</li>
<li>加上参数<code>header=F</code>，以避免输出关于包作者的一些信息。</li>
</ul>
<p>其余用法与上述使用说明基本相同。这样就可以直接输出如上所示的表格了。</p>
<hr>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><code>stargazer</code>用一行代码就可以解决模型结果输出成表格的问题，而且支持大量模型。具体可查看该包的<a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" title="stargezer.pdf" target="_blank" rel="external">说明文档</a>。</p>
<p>最后，如果在你的文章中有使用了<code>stargazer</code>包。记得附注以下作者的信息哦。</p>
<blockquote>
<p>Hlavac, Marek (2015). stargazer: Well-Formatted Regression and Summary Statistics Tables.<br>R package version 5.2. <a href="http://CRAN.R-project.org/package=stargazer" target="_blank" rel="external">http://CRAN.R-project.org/package=stargazer</a></p>
</blockquote>
<hr>
<p>点击链接到 <a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" title="stargezer.pdf" target="_blank" rel="external"><code>stargazer</code>包的说明文档地址</a></p>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;stargazer&lt;/code&gt;包可以将 R 构建的模型结果以&lt;code&gt;LATEX&lt;/code&gt;、&lt;cod
    
    </summary>
    
      <category term="R" scheme="https://vectorf.github.io/categories/R/"/>
    
    
      <category term="R" scheme="https://vectorf.github.io/tags/R/"/>
    
      <category term="stargazer" scheme="https://vectorf.github.io/tags/stargazer/"/>
    
  </entry>
  
  <entry>
    <title>揭开机器学习的面纱</title>
    <link href="https://vectorf.github.io/2017/02/20/20170221-%E6%8F%AD%E5%BC%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%9D%A2%E7%BA%B1/"/>
    <id>https://vectorf.github.io/2017/02/20/20170221-揭开机器学习的面纱/</id>
    <published>2017-02-20T08:30:30.000Z</published>
    <updated>2018-01-31T14:47:04.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://quantdare.com/2016/03/machine-learning-a-brief-breakdown/" target="_blank" rel="external">Machine Learning: A Brief Breakdown</a>   原文作者：libesa</p>
</blockquote>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/0.jpg" width="800" height="350" alt="0"><br><br></div>

<blockquote>
<p>你周围的人是否都在谈论着“机器学习”？而你是否也听说过一些算法技术却仍旧缺乏一个全局的认识？本文也许就是一个好的起点……</p>
</blockquote>
<h3 id="智力的新纪元"><a href="#智力的新纪元" class="headerlink" title="智力的新纪元"></a>智力的新纪元</h3><p>在科学界，机器学习是目前很热门的话题。通过把计算机和人类的能力相结合，一些相当复杂甚至是难以想象的问题正在被逐个突破。</p>
<p>如今的机器可以更容易地处理不断产生的大量数据，也能够对复杂的科学发现进行破译。另一方面，研究人员已经承认机器学习具有用于广泛领域的潜力，并且最终可以付诸实践。</p>
<p>当开始着手研究机器学习，我们会发现这其中很多的算法技术对于统计学家、工程师、程序员、数学家和金融工程师而言也许并不陌生。这是因为这些算法技术实际上已经被研究很多年了。“机器学习”是一个相对而言的新名词，但对于数据科学家而言这并不是一个完全陌生的领域。</p>
<p>本文汇总了原作者在研究初时遇到的一些有趣的实例，从而有助于理解机器学习的相关内容是如何联系在一起，并列出其知识体系各部分之间的不同之处，最终针对现有的项目，选择最佳的方案。</p>
<p>虽然本文并没有提出什么新的观点，甚至算不上专业，但原作者希望本文可以帮助那些对入门机器学习仍有疑惑的人。</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/1.jpg" alt="1"><br><br></div>

<h3 id="“机器学习”是什么？"><a href="#“机器学习”是什么？" class="headerlink" title="“机器学习”是什么？"></a>“机器学习”是什么？</h3><p>在机器学习领域，我们让机器自主学习。他们通过给定数据集里的案例进行学习。人们只需要利用机器得到的结论去改善方案、提高效率、实现自动化流程和任务。</p>
<p>让我们引用该领域两位巨擘的话来更精确地解释：</p>
<blockquote>
<p>“机器学习是让计算机在不被明确编程的情况下运作的科学。” ——安德鲁·吴（Coursera）</p>
<p>“一种计算机程序，如果它的任务记为T，用P来测度性能，并通过经验E来改善的话，它就会不断地从经验E中学习，从而满足某类任务T和性能指标P。”——汤姆·米歇尔（1997） </p>
</blockquote>
<h3 id="我曾经听说过这个！"><a href="#我曾经听说过这个！" class="headerlink" title="我曾经听说过这个！"></a>我曾经听说过这个！</h3><p>听起来，“机器学习”（简称为ML）和你之前了解的其他科学十分相似。现在，让我们看看它们之间究竟有什么不同。</p>
<p>或许，你对“人工智能”（简称为AI）更加熟悉。人工智能是通过复制人类的基本意识来开发系统项目从而独立完成预设好的目标的科学。很大程度上，机器学习可以算作是通过创造算法来调整机器行为从而接近经验数据的人工智能。</p>
<p>很多机器学习的内容来源于统计学科，只不过叫法不同罢了。与传统的统计学科不同，在机器学习中机器不对数据做推断，它得到的结论也不会被最初的诸多假设所限定。回想一下你在统计学中听到了多少次“假设X服从正态分布”或者“给定独立同分布的随机变量”。你有想过这些假设在现实中真的可能成立吗？</p>
<p>然而，机器学习方法的一个缺点在于我们很难得到对变量之间关系的直观解释，而这恰恰是统计推理所擅长的。为了实现更精确的预测，机器学习得到的模型会变得相当复杂以至于难以去解释。</p>
<p>失去解释性是绝大多数数据科学家不愿意见到的，但这也是为了解决复杂问题必须付出的代价。通常来说，在机器学习中最重要的是解决整个问题而不需要去分析细节。你能够不依赖其他技术发现数据背后隐藏的信息吗？尝试在下面这个色彩丰富的图中找出隐藏的三个物体，你能看到什么？</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/2.jpg" alt="2"><br><br></div>

<p>“机器学习”和“数据挖掘”也很相似。然而数据挖掘主要是为了发现数据中未知的模式和关系，机器学习则是在实际应用中通过先前得来的信息来处理新的数据集。</p>
<p>问题的关键在于平衡好性能和解释性的关系，比如说，预测准确性 vs 解释性。</p>
<p>如果你仍旧对机器学习与其他学科的异同留有困惑，你可以在<a href="https://www.analyticsvidhya.com/blog/2015/06/machine-learning-basics/" target="_blank" rel="external">“这里”</a>和<a href="http://shakthydoss.com/what-is-the-difference-between-artificial-intelligence-machine-learning-statistics-and-data-mining/" target="_blank" rel="external">“这里”</a>找到机器学习和人工智能、统计、数据挖掘、深度学习的比较。</p>
<h3 id="揭开机器学习的面纱"><a href="#揭开机器学习的面纱" class="headerlink" title="揭开机器学习的面纱"></a>揭开机器学习的面纱</h3><p>理解机器学习和学习如何入门最好的方法莫过于理解其知识体系各部分之间的不同之处。熟悉机器学习的人可能知道机器学习的主要模式就是监督学习和无监督学习了。</p>
<p>简而言之，监督学习就是我们已经通过之前已知的数据知道结果了。</p>
<p>此时，我们想建立一个模型来预测未知数据的结果。我们将已有的数据和结果输入机器，让它从这两者之间的关系中不断学习从而建立模型。</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/3.png" alt="3"><br><br></div>

<p>在无监督学习中，我们则是希望发现数据中未知的结构或者是趋势。原数据不含任何的标签，但我们希望可以对数据进行整合（分组或者聚类），或是简化数据（降维、移除不必要的变量或者检测异常值）。</p>
<p>我们进一步区分这两个模式的子类别，并在下图中展示出来：</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/4.png" alt="4"><br><br></div>

<p>监督学习可以根据预测变量的类型再细分。如果预测变量是连续的，那这就属于回归问题。</p>
<p>而如果预测变量是独立类别（定性或是定类的离散值），那这就属于分类问题了。</p>
<p>举例来说，如下两图所示：</p>
<ol>
<li>预测 S&amp;P500 指数下周的回报率。由于回报率是连续变量，这就是回归问题。</li>
<li>预测欧元兑美元的趋势是上升还是下降。这里只有两种可能性：牛市或熊市。这就是分类问题。</li>
</ol>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/5_0.png" alt="5_0"><br><br></div>

<p>无监督学习可以再细分为聚类分析、密度估计和降维。</p>
<p>聚类分析中，数据通过相似性或者距离来分组。密度估计中，模式和数据用分布函数或是定义的形状表示。降维中，通过移除重复或者不必要的变量实现更简洁的数据结构。</p>
<p>我们也可以根据学习的类型和所需解决的问题对特定的方法进行分类，如下图所示：</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/6.png" alt="6"><br><br></div>

<p><a href="http://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/" target="_blank" rel="external">“MLmastery”</a>和<a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" target="_blank" rel="external">“analyticsV”</a>等博文对机器学习主要的算法做了清晰实用的解释。</p>
<h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>机器学习技术在应用之前使用“训练+检验”的模式（通常被称作”交叉验证“）。</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/7.png" alt="7"><br><br></div>

<p>机器会不断地尝试参数的组合，因此我们要警惕“过拟合”和“运行时间”的问题。在训练阶段过高的准确性往往会造成过度优化，以至于在检验阶段会有较差的结果。同时，为了减小成本函数到足够的水平，算法也会花很长时间直至收敛到最终的结果。</p>
<h3 id="关于实际应用"><a href="#关于实际应用" class="headerlink" title="关于实际应用"></a>关于实际应用</h3><p>机器学习可谓是无处不在，在日常生活中有大量相关实例，只是我们没有意识到。比如说，机器学习被用于搜索引擎、过滤垃圾邮件、面部识别、社交网络分析、市场细分、数据分析、欺诈检测和风险分析等。</p>
<p>泛泛而谈是不足以说明问题的。通过将机器学习用于金融领域的实例，我们能看到将这些复杂的算法用于实际会带来多大的便利。</p>
<p>无监督学习技术可以用于分析和理解金融数据。比如说，<a href="http://quantdare.com/2014/03/analisis-de-componentes-principales/" target="_blank" rel="external">主成分分析（PCA）</a>可以用于资产配置，<a href="http://quantdare.com/2015/10/k-means-algorithm/" target="_blank" rel="external">K 均值</a>可用来债券市场回报率的聚类，<a href="http://quantdare.com/2015/05/reproducing-the-sp500-by-clustering/" target="_blank" rel="external">其他聚类方法</a>可以再现 S&amp;P 500指数的组成，<a href="http://quantdare.com/2016/01/stock-classification-with-isomap/" target="_blank" rel="external">ISOMAPS</a> 算法可以分类不同行业的股票。</p>
<p>监督学习技术则非常适合用于分析金融数据。它可以实现预测和帮助制定投资风险策略。举例来说，<a href="http://quantdare.com/2014/03/vecinos-serie-temporal/" target="_blank" rel="external">近邻算法</a>、<a href="http://quantdare.com/2014/07/redes-neuronales-ii/" target="_blank" rel="external">神经网络</a>、<a href="http://quantdare.com/2014/09/clasificando-mercado-con-arboles-de-decision/" target="_blank" rel="external">决策树</a>、<a href="http://quantdare.com/2015/01/random-forest-vs-simple-tree/" target="_blank" rel="external">随机森林</a>和<a href="http://quantdare.com/2015/10/naive_bayesian_classifier/" target="_blank" rel="external">贝叶斯</a>这些都可以用来监测股市的市场变动趋势。</p>
<h3 id="更多相关链接"><a href="#更多相关链接" class="headerlink" title="更多相关链接"></a>更多相关链接</h3><p>不知道从何开始？可以尝试<a href="https://www.coursera.org/learn/machine-learning/" target="_blank" rel="external">“在Coursera上的机器学习课程”</a>或者用Python的<a href="http://scikit-learn.org/stable/user_guide.html" target="_blank" rel="external">”tool scikit-learn“</a>。当然，你也可以在<a href="https://www.kaggle.com/competitions" target="_blank" rel="external">”Kaggle“</a>上进行学习，”泰坦尼克号’’实例很适合初学者。</p>
<p>想知道究竟什么算法才适合解决你的问题？不如去看看<a href="http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" rel="external">“scikit learn”</a>和<a href="https://azure.microsoft.com/en-us/documentation/articles/machine-learning-algorithm-choice/" target="_blank" rel="external">“Azure”</a>。</p>
<p>如果你想开始编程并尝试一些实例，<a href="http://topepo.github.io/caret/index.html" target="_blank" rel="external">“caret Package”</a>中包含大量的相关细节、函数和案例。你也可以从<a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">”Python and R codes“</a>中学到机器学习主要的算法。</p>
<p>不喜欢本文？想了解更多或想换个角度看？<a href="http://www.toptal.com/machine-learning/machine-learning-theory-an-introductory-primer" target="_blank" rel="external">“detailed post”</a>介绍了机器学习的入门知识，或是阅读<a href="http://www.r2d3.us/visual-intro-to-machine-learning-part-1/" target="_blank" rel="external">“innovative introductory visualisation”</a>。</p>
<p>在机器学习中有很多不同的词实际上代表同一样东西。下图是对于输入和输出变量的常见的一些表达方式：</p>
<div align="center"><br><br><img src="http://ofnqcf09s.bkt.clouddn.com/8.png" alt="8"><br><br></div>

<p>你也可以在<a href="http://robotics.stanford.edu/~ronnyk/glossary.html" target="_blank" rel="external">“Glossary”</a>找到更多与机器学习相关的术语。</p>
<hr>
<blockquote>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://quantdare.com/2016/03/machine-learning-a-brief-breakdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Machine Learn
    
    </summary>
    
      <category term="数据科学" scheme="https://vectorf.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="https://vectorf.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://vectorf.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="监督学习" scheme="https://vectorf.github.io/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="无监督学习" scheme="https://vectorf.github.io/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习与 Dota2 英雄属性</title>
    <link href="https://vectorf.github.io/2016/12/11/20161210-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8EDota2%E8%8B%B1%E9%9B%84%E5%B1%9E%E6%80%A7/"/>
    <id>https://vectorf.github.io/2016/12/11/20161210-机器学习与Dota2英雄属性/</id>
    <published>2016-12-11T08:30:30.000Z</published>
    <updated>2018-01-31T14:52:28.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://federicov.github.io/word-embeddings-and-dota2.html" target="_blank" rel="external">《 Gavagai 》</a>   原文作者：Federico Vaggi</p>
</blockquote>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/fenmian.jpg" width="800" height="350" alt="dota2"><br><br></div>

<p>本文使用自然语言处理（ NLP ）方法对 DOTA2 英雄角色属性做了简要的分析。</p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a><strong>1. 引言</strong></h2><p>如果有人问你“兔子”是什么意思，你会怎么回答？你可能会跑出去，每次看到一只兔子就指给那个人看，说“喏，那就是兔子。”当然那个人得和你三观相近，你才能解释得通。那如果对方对世界的认知方式和你不同，你要怎么向他解释？<br>这就是为什么要引入”词向量（ word vector ）”这个概念。”词向量”基于分布假定，即“语义相近的词语往往会出现在相似的内容中”。<br>在语言学中，如果你发现“ negotiate ”和“ bargain ”总是出现在相似的内容里，它们的语义就可能也是相近的。通过将词语向量化，再去计算向量化后“ negotiate ”和“ bargain ”的余弦相似度（一种测量两个向量间相似性的方法），你会发现相似度的值会接近 1 。词向量也常用于利用相似性去解释一些东西，比如说“皇帝”是“男人”，“皇后”就是“女人”。</p>
<h2 id="2-从词向量到英雄向量"><a href="#2-从词向量到英雄向量" class="headerlink" title="2. 从词向量到英雄向量"></a><strong>2. 从词向量到英雄向量</strong></h2><p>那么词向量怎么帮助我们去认识 Dota2 中的队伍呢？你可以想象每只 Dota2 的队伍配置都是由不同英雄做单词从而组成的句子，比如说：蝙蝠骑士、干扰者、拉席克、娜迦海妖、编织者，又或者：龙骑士、编织者、水晶室女、风行者、树精卫士。<br>正如上文提到的分布假定所说的那样，只是这次我们不通过每个词所在的句子去判断词语的意思，而是通过每个 Dota2 英雄所在的队伍去判断每个英雄的角色属性。具体来说，如果我们发现“巫医”和“莱恩”总是出现在相似的队伍里，那么他们可能就具有相似的角色属性。<br>本文使用 <a href="http://www.datdota.com/" target="_blank" rel="external">datdota</a> 作为数据来源，并使用 <a href="https://radimrehurek.com/gensim/index.html" target="_blank" rel="external">gensim library</a> 使我们的英雄向量化。<br>举例来说，通过对数据集的训练，“影魔”这个英雄向量化后大致如下：<br>[-0.06813218, -0.00902375, 0.10162564, -0.01908037, 0.03013835,<br>0.16538762, 0.03104097, 0.02496031, -0.16785616, 0.3313826 ,<br>-0.21904311, -0.07945664, 0.19140202, 0.12729862, 0.36308175,<br>0.19962946, 0.13561839, 0.23637122, -0.32607114, 0.05647549,<br>0.09655968, -0.21899879, 0.04926173, 0.12474103, 0.14504923,<br>0.06281823, 0.14728694, -0.03583163, -0.00227163, 0.1205247 ,<br>0.01127683, 0.01522848, 0.13806115, 0.0216765 , 0.13671157,<br>-0.1683237 , 0.00408782, 0.10514087, -0.17610508, 0.04697264,<br>-0.03406512, -0.14956233, 0.20201634, 0.00907436, -0.05804597,<br>-0.00481437, 0.11493918, -0.07718568, -0.13443205, -0.01155808]<br>这样，“影魔”这个英雄现在变成了 50 维空间里的一个点，但是把一个词变成 50 个数字并没有什么用处。现在来做一些炫酷的事吧！还是拿“影魔”为例，我们找出和它相似的一些英雄向量：</p>
<ol>
<li>痛苦女王：0.9340388774871826</li>
<li>风暴之灵：0.9170020818710327</li>
<li>冥界亚龙：0.9082884788513184</li>
<li>狙击手：0.8958033919334412</li>
<li>宙斯：0.8526902794837952</li>
</ol>
<p>（数字代表这些向量化后的英雄和“影魔”的余弦相似性）<br>下图则更直观地将结果进行展示，图中每行代表一个向量化后的英雄。</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/1.png" alt="1"><br><br></div>

<p>这就看起来有点感觉了，接下来再尝试一些更难的东西看看我们是不是能通过这些向量化后的英雄来解释它们之间的相似性，就像“莱恩”和“敌法师”相似，而“巫医”则和以下英雄相似：</p>
<ol>
<li>幽鬼：0.9638912677764893</li>
<li>幻影长矛手：0.9185065031051636</li>
<li>幻影刺客：0.9039324522018433</li>
<li>变体精灵：0.858444333076477</li>
<li>噬魂鬼：0.8570600748062134</li>
</ol>
<p>虽然这些分析可能不能帮助你打赢 PPD ,但至少下次你就知道该挑选哪些英雄来组队。</p>
<h2 id="3-全局视角"><a href="#3-全局视角" class="headerlink" title="3. 全局视角"></a><strong>3. 全局视角</strong></h2><p>我们可以把所有英雄同时展示在一张图里，但这难免让人眼花缭乱。</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/2.png" alt="2"><br><br></div>

<p>如上图所示，每一列对应一个英雄，并把行列以树状图的形式展示出来。不过除非你已经看惯了这些图，不然直观地分清哪些英雄是一类的或者判断出哪个英雄和别的相似还是挺难的。<br>我们将树状图精简展示出来，来看看那些英雄是相似的，结果如下图所示：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/3.png" alt="3"><br><br></div>

<p>截至目前，我们已经得到了一些有意义（虽然并不完美）的英雄分类群体了，比如“劣势路单”群体包括了末日使者、司夜刺客、黑暗贤者、钢背兽和半人马战行者，“强核心”群体包括了卓尔游侠、斯拉克、幻影长矛手和噬魂鬼，而“力量支持”群体则包括了冥魂大帝、巨牙海民和亚巴顿。<br>当然有其他方式来展示分类的结果。我们可以使用 <a href="https://lvdmaaten.github.io/tsne/" target="_blank" rel="external">t-SNE</a> 将 50 维的数据以二维的形式展示出来。 <a href="https://lvdmaaten.github.io/tsne/" target="_blank" rel="external">t-SNE</a> 是一种在尽可能不破坏原有高维数据结构的基础上以低维形式展示数据的方法。<br>在对数据进行处理并在二维空间绘图后，我们可以得到下图：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/4.png" alt="4"><br><br></div>

<p>图中英雄不同的颜色来自于上文的分类结果，直观地看这些离散分类还是具有一定意义的。</p>
<h2 id="4-向量到底代表什么？"><a href="#4-向量到底代表什么？" class="headerlink" title="4. 向量到底代表什么？"></a><strong>4. 向量到底代表什么？</strong></h2><p>那么我们给每个英雄赋的值到底代表什么呢？“影魔”在第一维空间里的值为 -0.06813218 ，这个值代表什么意思？通常情况下，我们会说这些是潜在的属性值，就不再深究了。但在这个实例里，我们可以再深入一点。<br><a href="http://dota2.gamepedia.com/Dota_2_Wiki" target="_blank" rel="external">Dota2 gamepedia</a> 给每个英雄都赋予了一系列角色属性。虽然这个属性有待商榷，而且在打完补丁之后有的英雄可能会从辅助变成核心，但是这仍然可以作为一个不错的出发点。<br>现在，我们已经为接下来的分析做好准备了。回想一下之前我们已经用 50 个数字来刻画每个英雄了，并且从 <a href="http://dota2.gamepedia.com/Dota_2_Wiki" target="_blank" rel="external">Dota2 gamepedia</a> 网站中也有了每个英雄对应的角色属性。<br>我们想验证向量维度和英雄的角色属性之间是否有一定的联系。有很多方法可以实现，但可能最简单的方式就是使用 Logistic 回归了。<br>为了能得到稀疏集，我们使用 L1 范数规则化。<br>结果如下图所示：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/5.png" alt="5"><br><br></div>

<p>这幅图又意味着什么呢？我们可以看到第 46 个向量和“辅助”有很强的相关性，第 38 个向量和“远程英雄”联系紧密。下图是所有英雄第 38 和第 46 个向量值的散点图：</p>
<div align="center"><br><br><img src="http://ohz7hgskn.bkt.clouddn.com/6.png" alt="6"><br><br></div>

<p>可以看出第 46 个向量值大的英雄很可能是辅助英雄。相似地，第 38 个向量值大的英雄很可能是打远程的。当然，你可能注意到这两个向量似乎有点相关（虽然相关性并不是那么强），不过这也正好与辅助英雄往往也是打远程的情况相符。上图也将不朽尸王、上古巨神、亚巴顿这些近战支援（辅助属性高，远程属性低）的英雄正确识别出来了，但卓尔游侠的向量值却和角色属性不符，而且克林克兹也是一个近战支援的英雄（图中其第 38 和 46 个向量值都不高，与事实不太相符）。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h2><p>一旦涉及到计算机领域，每次英雄的选派都可以看作是没有实际意义的随机序列，但是从这里出发，却能得到可以被较好解释的信息。因此，在训练这些向量值时，我们并没有使用任何从 Dota2 得到的英雄属性信息。<br>我们可以将 Dota2 英雄的选派看作是我们不会说的一门外语。通过观察这些词的使用模式，找出词意相近的词语。<br>进一步地，通过连接在无监督学习下得到的分类特征，我们能够解释这些潜在属性。</p>
<hr>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://federicov.github.io/word-embeddings-and-dota2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《 Gavagai 》&lt;/a&gt;   原文
    
    </summary>
    
      <category term="数据科学" scheme="https://vectorf.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="https://vectorf.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://vectorf.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Dota2" scheme="https://vectorf.github.io/tags/Dota2/"/>
    
      <category term="自然语言处理" scheme="https://vectorf.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="词向量" scheme="https://vectorf.github.io/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git 教程</title>
    <link href="https://vectorf.github.io/2016/11/06/20161106-Git%20%E6%95%99%E7%A8%8B/"/>
    <id>https://vectorf.github.io/2016/11/06/20161106-Git 教程/</id>
    <published>2016-11-06T12:30:30.000Z</published>
    <updated>2018-01-31T14:42:30.557Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br><br><img src="http://ofa07l4yq.bkt.clouddn.com/git.jpg" alt="git"><br><br></div>

<blockquote>
<p>本 Git 教程根据 <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a> 整理总结而来，非原创。</p>
</blockquote>
<h2 id="一、安装后的配置"><a href="#一、安装后的配置" class="headerlink" title="一、安装后的配置"></a><strong>一、安装后的配置</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure>
<h2 id="二、创建版本库"><a href="#二、创建版本库" class="headerlink" title="二、创建版本库"></a><strong>二、创建版本库</strong></h2><p>1.创建新的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir gittest</div><div class="line">$ cd ngittest</div><div class="line">$ pwd</div></pre></td></tr></table></figure>
<p><code>mkdir</code>创建新目录，<code>cd</code>定位到该目录，<code>pwd</code>显示当前目录。</p>
<p>2.<code>git init</code>将该目录变成git可以管理的仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ ls -ah</div></pre></td></tr></table></figure>
<p>3.把文件添加到版本库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add readme.txt</div><div class="line">$ git commit -m &quot;wrote a readme flie&quot;</div></pre></td></tr></table></figure>
<p>4.查看仓库的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git status</div></pre></td></tr></table></figure>
<p>5.查看更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff</div></pre></td></tr></table></figure>
<p>6.查看提交历史记录，按<code>q</code>可退出该命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git log</div><div class="line">$ git log --pretty=oneline</div></pre></td></tr></table></figure>
<p>7.查看命令历史记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reflog</div></pre></td></tr></table></figure>
<p>8.版本回退及撤销回退</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard HEAD^^</div><div class="line">$ cat readme.txt</div><div class="line">$ git reset --hard commit_id</div></pre></td></tr></table></figure>
<p>**注意：原教程中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>；但在实际中，貌似<code>HEAD^</code>是当前版本，<code>HEAD^^</code>是恢复到上一个版本。</p>
<p>9.对比工作区和版本库中的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git diff HEAD^ -- readme.txt</div></pre></td></tr></table></figure>
<p>10.撤销修改</p>
<ul>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
</ul>
<p>对readme.txt进行修改后，使用<code>git checkout -- file</code>丢弃工作区的修改。这里有两种情况：</p>
<p>一种是<code>README.md</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>README.md</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- readme.txt</div></pre></td></tr></table></figure>
<ul>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD^ readme.txt</div><div class="line">$ git checkout -- readme.txt</div></pre></td></tr></table></figure>
<ul>
<li>已经提交了不合适的修改到版本库时，想要撤销本次提交，可使用版本回退，不过前提是没有推送到远程库。</li>
</ul>
<p>11.删除文件</p>
<p>删除工作区的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm test.txt</div></pre></td></tr></table></figure>
<ul>
<li>如果需要在版本库中也删除该文件，使用<code>git rm</code>，并且<code>git commit</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git rm test.txt</div><div class="line">$ git commit -m &quot;remove test.txt&quot;</div></pre></td></tr></table></figure>
<ul>
<li>如果是在工作区误删了文件，则需通过版本库恢复到最新版本。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout --test.txt</div></pre></td></tr></table></figure>
<h2 id="三、远程仓库"><a href="#三、远程仓库" class="headerlink" title="三、远程仓库"></a><strong>三、远程仓库</strong></h2><p>1.创建 SSH key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</div></pre></td></tr></table></figure>
<p>在用户主目录中找到<code>id_rsa.pub</code>，粘贴进 Github。</p>
<p>2.添加远程库</p>
<p>先在 Github 上创建一个仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:yourusername/gittest.git</div></pre></td></tr></table></figure>
<p>**注意：远程库的名字就是<code>origin</code>，也可改成别的，但一般用<code>origin</code>。</p>
<p>将本地库的内容推送到远程库上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<p>第一次推送<code>master</code>分支时，要用<code>-u</code>参数。之后就可以只用<code>git push origin master</code></p>
<p>3.从远程库克隆</p>
<p>先在 Github 上创建一个新的仓库，名字叫<code>gitskills</code>。</p>
<p>用命令<code>git clone</code>克隆一个本地库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github.com:yourusername/gitskills.git</div><div class="line">$ cd gitskills</div><div class="line">$ ls</div></pre></td></tr></table></figure>
<p>**注意：Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p>
<h2 id="四、分支管理"><a href="#四、分支管理" class="headerlink" title="四、分支管理"></a><strong>四、分支管理</strong></h2><p>1.创建与合并分支</p>
<ul>
<li>创建<code>dev</code>分支，并切换到<code>dev</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch &apos;dev&apos;</div></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line">$ git checkout dev</div><div class="line">Switched to branch &apos;dev&apos;</div></pre></td></tr></table></figure>
<ul>
<li>然后，用<code>git branch</code>命令查看当前分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* dev</div><div class="line">  master</div></pre></td></tr></table></figure>
<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<ul>
<li>之后就可以在<code>dev</code>分支上正常提交，比如对README.md做个修改，加上一行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick.</div></pre></td></tr></table></figure>
<p>然后提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;branch test&quot;</div></pre></td></tr></table></figure>
<ul>
<li>切换回<code>master</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div></pre></td></tr></table></figure>
<p>再查看 README.md 文件，刚才添加的内容不见了。因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变</p>
<ul>
<li>把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge dev</div><div class="line">Updating ********</div><div class="line">Fast-forward</div><div class="line"> README.md | 4 +++-</div><div class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</div></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看 README.md 的内容，可看到和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>**注意：上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。并非每次合并都能<code>Fast-forward</code>。</p>
<ul>
<li>合并后，可删除<code>dev</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -d dev</div><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure>
<p>2.解决冲突</p>
<ul>
<li>准备新的<code>feature1</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature1</div></pre></td></tr></table></figure>
<p>修改README.md最后一行，改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick AND simple.</div></pre></td></tr></table></figure>
<p>在<code>featrure1</code>分支上提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;AND simple&quot;</div></pre></td></tr></table></figure>
<ul>
<li>切换到<code>master</code>分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch &apos;master&apos;</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</div></pre></td></tr></table></figure>
<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把README.md的最后一行改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick &amp; simple.</div></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md </div><div class="line">$ git commit -m &quot;&amp; simple&quot;</div></pre></td></tr></table></figure>
<ul>
<li>合并</li>
</ul>
<p>若直接使用<code>marge</code>命令，会产生冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge freature1</div><div class="line">Auto-merging README.md</div><div class="line">CONFLICT (content): Merge conflict in README.md</div><div class="line">Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>
<p><code>git status</code>命令可告诉我们冲突的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is ahead of &apos;origin/master&apos; by 2 commits.</div><div class="line">  (use &quot;git push&quot; to publish your local commits)</div><div class="line">You have unmerged paths.</div><div class="line">  (fix conflicts and run &quot;git commit&quot;)</div><div class="line">  (use &quot;git merge --abort&quot; to abort the merge)</div><div class="line"></div><div class="line">Unmerged paths:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</div><div class="line"></div><div class="line">        both modified:   README.md</div><div class="line"></div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div></pre></td></tr></table></figure>
<p>此时，直接查看README.md中的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># gitskills</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">Creating a new branch is quick &amp; simple.</div><div class="line">=======</div><div class="line">Creating a new branch is quick AND simple.</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</div></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Creating a new branch is quick and simple.</div></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;conflict fixed&quot;</div></pre></td></tr></table></figure>
<p>用带参数的<code>git log</code>可看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div></pre></td></tr></table></figure>
<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature1</div></pre></td></tr></table></figure>
<ul>
<li><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
</li>
</ul>
<p>3.分支策略管理</p>
<p>通常，Git 会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢失分支信息。</p>
<p>如果强制禁用<code>Fast forward</code>模式，Git 就会在merge时生成一个新的commit，这样分支历史上就可看到分支信息。</p>
<p>实际开发中，<code>master</code>分支应当是稳定的，仅用来发布新版本，平时不在上面干活；</p>
<p>而<code>dev</code>分支是不稳定的，在这上面干活。等到新版本需要发布时，把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支上发布新版本。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<ul>
<li>使用<code>--no-ff</code>方式的<code>git merge</code></li>
</ul>
<p>首先，创建并切换<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev</div></pre></td></tr></table></figure>
<p>修改README.md文件，并提交一个新的commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;add merge&quot;</div></pre></td></tr></table></figure>
<p>接下来，切换回<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout merge</div></pre></td></tr></table></figure>
<p>使用<code>--no-ff</code>参数（表示禁用<code>Fast forward</code>）合并<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</div></pre></td></tr></table></figure>
<p>**注意：因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，用<code>git log</code>查看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --pretty=oneline --abbrev-commit</div><div class="line">*   f808280 merge with no-ff</div><div class="line">|\</div><div class="line">| * 081f9ca add merge</div><div class="line">|/</div><div class="line">*   fe3d2cc conflict fixed</div></pre></td></tr></table></figure>
<p>4.Bug 分支</p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p>假定此时需要创建一个分支<code>issue-101</code>来修复代号101的bug的任务。</p>
<p>Git 提供一个<code>stash</code>功能，把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash</div></pre></td></tr></table></figure>
<p>现在用<code>git status</code>查看工作区，就是干净的。</p>
<ul>
<li>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git checkout -b issue-101</div></pre></td></tr></table></figure>
<p>现在修复bug，任意修改README.md ，然后提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README.md</div><div class="line">$ git commit -m &quot;fix bug 101&quot;</div></pre></td></tr></table></figure>
<ul>
<li>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</div><div class="line">$ git branch -d issue-101</div></pre></td></tr></table></figure>
<ul>
<li>回到<code>dev</code>分支干活：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div><div class="line">$ git status</div></pre></td></tr></table></figure>
<p>工作区是干净的，用<code>git stash list</code>命令查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div></pre></td></tr></table></figure>
<p>有两种方法恢复工作区：</p>
<ul>
<li>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li>
<li>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash pop</div></pre></td></tr></table></figure>
<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div></pre></td></tr></table></figure>
<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash apply stash@&#123;0&#125;</div></pre></td></tr></table></figure>
<p>5.Feature 分支</p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D</code>强行删除。</p>
<ul>
<li>假设需添加一个开发代号为Vulcan的新功能。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b feature-vulcan</div><div class="line">$ git add vulcan.py</div><div class="line">$ git commit -m &quot;add feature vulcan&quot;</div></pre></td></tr></table></figure>
<p>切回<code>dev</code>，准备合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<p>如果此时必须销毁该<code>feature-vulcan</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch -d feature-vulcan</div><div class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</div><div class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</div></pre></td></tr></table></figure>
<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令<code>git branch -D feature-vulcan</code>。</p>
<p>现在，强行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -D feature-vulcan</div></pre></td></tr></table></figure>
<p>6.多人协作</p>
<p>多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to=origin/&lt;branch&gt; dev</code>。</p>
<ul>
<li>实际上，从远程仓库克隆时 Git 自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</li>
</ul>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote</div></pre></td></tr></table></figure>
<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin  git@github.com:yourusername/gittest.git (fetch)</div><div class="line">origin  git@github.com:yourusername/gittest.git (push)</div></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<ul>
<li>推送分支：把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<p><code>master</code>分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p><code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<ul>
<li>抓取分支</li>
</ul>
<p>模拟一个小伙伴，在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github.com:yourusername/gittest.git</div></pre></td></tr></table></figure>
<p>从远程库clone时，默认情况下只能看到本地的<code>master</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure>
<p>要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev origin/dev</div></pre></td></tr></table></figure>
<p>现在就可以在<code>dev</code>上继续修改。然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;add devtest.txt&quot;</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add devtest.txt</div><div class="line">$ git commit -m &quot;add aaa&quot;</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<p>推送失败。解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull</div></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接，再 pull ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch --set-upstream-to=origin/dev dev</div><div class="line">$ git pull</div></pre></td></tr></table></figure>
<p>**注意：原教程中使用的是<code>git branch --set-upstream dev origin/&lt;branch&gt;</code>命令。</p>
<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的”解决冲突”完全一样。解决后，提交，再push：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;merge &amp; fix devtest.txt&quot;</div><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<h2 id="五、标签管理"><a href="#五、标签管理" class="headerlink" title="五、标签管理"></a><strong>五、标签管理</strong></h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），标签也是版本库的一个快照。</p>
<p>标签是指向某个 commit 的指针（和分支相似，但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p>
<p>1.创建标签</p>
<p>首先，切换到需要到打标签的分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">$ git checkout master</div></pre></td></tr></table></figure>
<p>然后，命令<code>git tag</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id。</p>
<p>敲命令<code>git tag</code>就可以打一个新标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.0</div></pre></td></tr></table></figure>
<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v1.0</div></pre></td></tr></table></figure>
<p>默认标签是打在最新提交的commit上的。如果需要对当前时间之前的 commit 打标签，就需要找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git log --pretty=oneline --abbrev-commit</div><div class="line">477debf add test.txt</div><div class="line">5b24428 git tracks changes of files</div><div class="line">2367db6 git tracks changes</div><div class="line">29f5a3c understand how stage works</div><div class="line">e5f00d8 append gpl</div><div class="line">64106a2 add distributed</div><div class="line">2a9a448 wtrote a readme file</div></pre></td></tr></table></figure>
<p>比方说要对<code>git tracks changes of files</code>这次提交打标签，它对应的commit id是<code>5b24428</code>，敲入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v0.9 5b24428</div></pre></td></tr></table></figure>
<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v0.9</div><div class="line">v1.0</div></pre></td></tr></table></figure>
<p>**注意：标签不是按时间顺序列出，而是按字母排序的。</p>
<p>可以用<code>git show</code>查看标签信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v0.9</div></pre></td></tr></table></figure>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 2a9a448</div></pre></td></tr></table></figure>
<p>用命令<code>git show</code>可以看到说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v0.1</div></pre></td></tr></table></figure>
<p>还可以通过<code>-s</code>用私钥签名一个标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; 64106a2</div></pre></td></tr></table></figure>
<p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gpg: signing failed: secret key not available</div><div class="line">error: gpg failed to sign the data</div><div class="line">error: unable to sign the tag</div></pre></td></tr></table></figure>
<p>如果报错，请参考GnuPG帮助文档配置Key。</p>
<p>用命令<code>git show</code>可以看到PGP签名信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v0.2</div></pre></td></tr></table></figure>
<p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名。</p>
<p>2.操作标签</p>
<p>删除标签，使用命令<code>git tag -d &lt;tagname&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -d v0.1</div></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>，或者一次性推送全部尚未推送到远程的本地标签，使用命令<code>git push origin --tags</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.0</div><div class="line">$ git push origin --tags</div></pre></td></tr></table></figure>
<p>如果标签已经推送到远程，先从本地删除，再从远程删除，使用命令<code>git push origin :refs/tags/</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -d v0.9</div><div class="line">$ git push origin :refs/tags/v0.9</div></pre></td></tr></table></figure>
<h2 id="六、Github"><a href="#六、Github" class="headerlink" title="六、Github"></a><strong>六、Github</strong></h2><p>访问想要 Fork 的仓库，在自己的账号下克隆，然后使用<code>git clone &lt;address&gt;</code>命令 clone 到本地进行修改。</p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h2 id="七、自定义-Git"><a href="#七、自定义-Git" class="headerlink" title="七、自定义 Git"></a><strong>七、自定义 Git</strong></h2><p>在“安装Git”一节中，已经配置了<code>user.name</code>和<code>user.email</code>。</p>
<p>如果想让 Git 显示颜色，让命令输出看起来更醒目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global color.ui true</div></pre></td></tr></table></figure>
<p>1.忽略特殊文件</p>
<ul>
<li>忽略某些文件时，需要编写<code>.gitignore</code>；</li>
<li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li>
</ul>
<p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p><code>.gitignore</code>文件内容的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># Windows:</div><div class="line">Thumbs.db</div><div class="line">ehthumbs.db</div><div class="line">Desktop.ini</div><div class="line"></div><div class="line"># Python:</div><div class="line">*.py[cod]</div><div class="line">*.so</div><div class="line">*.egg</div><div class="line">*.egg-info</div><div class="line">dist</div><div class="line">build</div><div class="line"></div><div class="line"># My configurations:</div><div class="line">db.ini</div><div class="line">deploy_key_rsa</div></pre></td></tr></table></figure>
<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>在 Windows 环境下，如果在资源管理器里新建一个<code>.gitignore</code>文件，它会提示必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git add App.class</div><div class="line">The following paths are ignored by one of your .gitignore files:</div><div class="line">App.class</div><div class="line">Use -f if you really want to add them.</div></pre></td></tr></table></figure>
<p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add -f App.class</div></pre></td></tr></table></figure>
<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git check-ignore -v App.class</div><div class="line">.gitignore:3:*.class    App.class</div></pre></td></tr></table></figure>
<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p>2.配置别名</p>
<p>如果想敲<code>git st</code>就可以表示<code>git status</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure>
<p>当然可以用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.co checkout</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.br branch</div></pre></td></tr></table></figure>
<p>以后提交就可以简写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git ci -m &quot;bala bala bala...&quot;</div></pre></td></tr></table></figure>
<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>用<code>unstage</code>表示<code>reset HEAD</code>，把暂存区的修改撤销掉（unstage），重新放回工作区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</div></pre></td></tr></table></figure>
<p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.last &apos;log -1&apos;</div></pre></td></tr></table></figure>
<p>把<code>lg</code>配置成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure>
<ul>
<li>配置文件</li>
</ul>
<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ cat .git/config </div><div class="line">[core]</div><div class="line">    repositoryformatversion = 0</div><div class="line">    filemode = true</div><div class="line">    bare = false</div><div class="line">    logallrefupdates = true</div><div class="line">    ignorecase = true</div><div class="line">    precomposeunicode = true</div><div class="line">[remote &quot;origin&quot;]</div><div class="line">    url = git@github.com:yourusername/gittest.git</div><div class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">[branch &quot;master&quot;]</div><div class="line">    remote = origin</div><div class="line">    merge = refs/heads/master</div><div class="line">[alias]</div><div class="line">    last = log -1</div></pre></td></tr></table></figure>
<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat .gitconfig</div><div class="line">[alias]</div><div class="line">    co = checkout</div><div class="line">    ci = commit</div><div class="line">    br = branch</div><div class="line">    st = status</div><div class="line">[user]</div><div class="line">    name = Your Name</div><div class="line">    email = your@email.com</div></pre></td></tr></table></figure>
<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<p>3.搭建 Git 服务器</p>
<p>等我装个 ubuntu 再试试……</p>
<hr>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ofa07l4yq.bkt.clouddn.com/git.jpg&quot; alt=&quot;git&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;本 Git 教程根据 &lt;a href
    
    </summary>
    
      <category term="Git" scheme="https://vectorf.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://vectorf.github.io/tags/Git/"/>
    
      <category term="教程" scheme="https://vectorf.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>永不过时的 K 均值算法</title>
    <link href="https://vectorf.github.io/2016/10/21/20161021-Translate-K-Means/"/>
    <id>https://vectorf.github.io/2016/10/21/20161021-Translate-K-Means/</id>
    <published>2016-10-21T13:27:17.000Z</published>
    <updated>2018-01-31T14:37:06.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://quantdare.com/2016/04/k-means-vs-k-medoids/" target="_blank" rel="external">《”K-Means never fails”, they said…》</a> &ensp; 原文作者：Fjrodriguez2</p>
</blockquote>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>众所周知，数据挖掘算法并非十全十美，在某些情况下他们也会失效。 使用 K 均值算法（K-Means）时就可能会出现这种情况，当然此时你可以尝试一下另一种方法—— K 中心聚类算法（K-Medoids），也许效果会更好。</p>
<p>在该网站之前的文章《揭开机器学习的面纱》中，已经指出， K 均值算法用于聚类时效果良好，而且在数据挖掘和机器学习领域，它也有着重要的地位。Psanchezcri 就曾在他的文章《将 K 均值方法用于金融时序回报率聚类》中，将 K 均值算法用于分析金融时间序列的趋势。</p>
<p>然而，即使在网络上有关算法的文档浩如烟海的情况下，关于机器学习算法有时会失效的讨论却并不多见。</p>
<p>因此，本文借由一个金融案例来反映这个问题。</p>
<hr>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>1）首先，我们在欧洲斯托克600指数的成分股中选择三组共6只股票（在三个不同的部门中各选两只）：</p>
<ul>
<li><p>金融部门：  西班牙毕尔巴鄂比斯开银行 &amp; 桑坦德银行</p>
</li>
<li><p>非必需消费品：  法国酩悦·轩尼诗－路易·威登 &amp; 迪奥</p>
</li>
<li><p>能源部门：  英国石油公司 &amp; 锡尼什港能源公司</p>
</li>
</ul>
<p>2）搜集数据，并绘出在2013/01/01至2015/12/31期间这六只股票的价格走势曲线。如下所示：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/1.png" alt="1"><br></div>


<p>3）选择日回报率作为计算指标，我们算出三组股票序列的相关距离。然后通过距离矩阵降维的方法，在二维欧氏空间中绘出每个点。</p>
<p>结果显示这六只股票可以按部门进行分类效果显著。下图以蓝色菱形点、绿色正方形点、红色圆点来标记六只股票，明显可以按部门分为三类：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/2.png" alt="2"><br></div>


<p>4）最后，我们将 K 均值算法运用于距离矩阵，聚类目标预先设定分成3类。由于 K 均值算法是从随机点开始的，每次运行结果可能有所不同，本文我们预先设定运行这个算法15次，即产生15个结果。当然，我们希望得到聚类结果符合股票所属部门的实际情况。</p>
<hr>
<h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>１）在约80%的聚类结果中，K 均值聚类算法取得了理想的结果，聚类结果与这六只股票所属部门相符，如下图所示：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/3.png" alt="3"><br></div>


<p>２）在剩下的20%的聚类结果中，算法则出现了聚类的错误。例如，下图中错将两个不同部门的四只股票聚为一类（图中蓝色菱形点和绿色正方形点），而将同一部门的两只股票分为两类（图中红色圆点）：</p>
<div align="center"><br><img src="http://od7vqa3z1.bkt.clouddn.com/4.png" alt="4"><br></div>


<p>如果我们使用与之思想类似的 K 中心聚类算法，结果则可以达到100%的正确聚类率。这表明在聚类时，似乎使用重心会比用均值来衡量距离，效果更好。</p>
<hr>
<p>转载请注明来自 <a href="https://vectorf.github.io/">Vector Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://quantdare.com/2016/04/k-means-vs-k-medoids/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《”K-Means never fails”, the
    
    </summary>
    
      <category term="数据科学" scheme="https://vectorf.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="K 均值" scheme="https://vectorf.github.io/tags/K-%E5%9D%87%E5%80%BC/"/>
    
      <category term="聚类" scheme="https://vectorf.github.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="机器学习" scheme="https://vectorf.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://vectorf.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博文</title>
    <link href="https://vectorf.github.io/2016/10/19/20161019-my-first-post/"/>
    <id>https://vectorf.github.io/2016/10/19/20161019-my-first-post/</id>
    <published>2016-10-19T05:31:17.000Z</published>
    <updated>2018-01-31T14:35:59.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world !"></a>Hello, world !</h2><p><a id="more"></a>你好呀！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hello-world&quot;&gt;&lt;a href=&quot;#Hello-world&quot; class=&quot;headerlink&quot; title=&quot;Hello, world !&quot;&gt;&lt;/a&gt;Hello, world !&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="日常" scheme="https://vectorf.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="https://vectorf.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
